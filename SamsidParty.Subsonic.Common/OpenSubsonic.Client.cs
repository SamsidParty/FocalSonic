//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace SamsidParty.Subsonic.Common
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IClient
    {
        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> GetAddChatMessageAsync(string message);

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse GetAddChatMessage(string message);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> GetAddChatMessageAsync(string message, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostAddChatMessageAsync(Body body);

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostAddChatMessage(Body body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostAddChatMessageAsync(Body body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> ChangePasswordAsync(string username, string password);

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse ChangePassword(string username, string password);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> ChangePasswordAsync(string username, string password, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostChangePasswordAsync(Body2 body);

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostChangePassword(Body2 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostChangePasswordAsync(Body2 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateBookmarkAsync(string id, int position, string comment);

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse CreateBookmark(string id, int position, string comment);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateBookmarkAsync(string id, int position, string comment, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateBookmarkAsync(Body3 body);

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostCreateBookmark(Body3 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateBookmarkAsync(Body3 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateInternetRadioStationAsync(string streamUrl, string name, string homepageUrl);

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse CreateInternetRadioStation(string streamUrl, string name, string homepageUrl);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateInternetRadioStationAsync(string streamUrl, string name, string homepageUrl, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateInternetRadioStationAsync(Body4 body);

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostCreateInternetRadioStation(Body4 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateInternetRadioStationAsync(Body4 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreatePlaylistResponse> CreatePlaylistAsync(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId);

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        CreatePlaylistResponse CreatePlaylist(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreatePlaylistResponse> CreatePlaylistAsync(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreatePlaylistResponse> PostCreatePlaylistAsync(Body5 body);

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        CreatePlaylistResponse PostCreatePlaylist(Body5 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreatePlaylistResponse> PostCreatePlaylistAsync(Body5 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreatePodcastChannelAsync(string url);

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse CreatePodcastChannel(string url);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreatePodcastChannelAsync(string url, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreatePodcastChannelAsync(Body6 body);

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostCreatePodcastChannel(Body6 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreatePodcastChannelAsync(Body6 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateSharesResponse> CreateShareAsync(System.Collections.Generic.IEnumerable<string> id, string description, int? expires);

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        CreateSharesResponse CreateShare(System.Collections.Generic.IEnumerable<string> id, string description, int? expires);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateSharesResponse> CreateShareAsync(System.Collections.Generic.IEnumerable<string> id, string description, int? expires, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateSharesResponse> PostCreateShareAsync(Body7 body);

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        CreateSharesResponse PostCreateShare(Body7 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateSharesResponse> PostCreateShareAsync(Body7 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId);

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse CreateUser(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> CreateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateUserAsync(Body8 body);

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostCreateUser(Body8 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostCreateUserAsync(Body8 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteBookmarkAsync(string id);

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeleteBookmark(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteBookmarkAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteBookmarkAsync(Body9 body);

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeleteBookmark(Body9 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteBookmarkAsync(Body9 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteInternetRadioStationAsync(string id);

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeleteInternetRadioStation(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteInternetRadioStationAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteInternetRadioStationAsync(Body10 body);

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeleteInternetRadioStation(Body10 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteInternetRadioStationAsync(Body10 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePlaylistAsync(string id);

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeletePlaylist(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePlaylistAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePlaylistAsync(Body11 body);

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeletePlaylist(Body11 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePlaylistAsync(Body11 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastChannelAsync(string id);

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeletePodcastChannel(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastChannelAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastChannelAsync(Body12 body);

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeletePodcastChannel(Body12 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastChannelAsync(Body12 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastEpisodeAsync(string id);

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeletePodcastEpisode(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastEpisodeAsync(Body13 body);

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeletePodcastEpisode(Body13 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastEpisodeAsync(Body13 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteShareAsync(string id);

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeleteShare(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteShareAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteShareAsync(Body14 body);

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeleteShare(Body14 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteShareAsync(Body14 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteUserAsync(string username);

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DeleteUser(string username);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DeleteUserAsync(string username, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteUserAsync(Body15 body);

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDeleteUser(Body15 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDeleteUserAsync(Body15 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> DownloadAsync(string id);

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse Download(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> DownloadAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostDownloadAsync(Body16 body);

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse PostDownload(Body16 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostDownloadAsync(Body16 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DownloadPodcastEpisodeAsync(string id);

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse DownloadPodcastEpisode(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> DownloadPodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDownloadPodcastEpisodeAsync(Body17 body);

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostDownloadPodcastEpisode(Body17 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostDownloadPodcastEpisodeAsync(Body17 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumResponse> GetAlbumAsync(string id);

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumResponse GetAlbum(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumResponse> GetAlbumAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumResponse> PostGetAlbumAsync(Body18 body);

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumResponse PostGetAlbum(Body18 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumResponse> PostGetAlbumAsync(Body18 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfoAsync(string id);

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumInfoResponse GetAlbumInfo(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfoAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfoAsync(Body19 body);

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumInfoResponse PostGetAlbumInfo(Body19 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfoAsync(Body19 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfo2Async(string id);

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumInfoResponse GetAlbumInfo2(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfo2Async(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfo2Async(Body20 body);

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumInfoResponse PostGetAlbumInfo2(Body20 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfo2Async(Body20 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumListResponse> GetAlbumListAsync(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumListResponse GetAlbumList(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumListResponse> GetAlbumListAsync(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumListResponse> PostGetAlbumListAsync(Body21 body);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumListResponse PostGetAlbumList(Body21 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumListResponse> PostGetAlbumListAsync(Body21 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumList2Response> GetAlbumList2Async(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumList2Response GetAlbumList2(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumList2Response> GetAlbumList2Async(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumList2Response> PostGetAlbumList2Async(Body22 body);

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetAlbumList2Response PostGetAlbumList2(Body22 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetAlbumList2Response> PostGetAlbumList2Async(Body22 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistResponse> GetArtistAsync(string id);

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistResponse GetArtist(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistResponse> GetArtistAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistResponse> PostGetArtistAsync(Body23 body);

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistResponse PostGetArtist(Body23 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistResponse> PostGetArtistAsync(Body23 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfoResponse> GetArtistInfoAsync(string id, int? count, bool? includeNotPresent);

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistInfoResponse GetArtistInfo(string id, int? count, bool? includeNotPresent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfoResponse> GetArtistInfoAsync(string id, int? count, bool? includeNotPresent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfoResponse> PostGetArtistInfoAsync(Body24 body);

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistInfoResponse PostGetArtistInfo(Body24 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfoResponse> PostGetArtistInfoAsync(Body24 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfo2Response> GetArtistInfo2Async(string id, int? count, bool? includeNotPresent);

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistInfo2Response GetArtistInfo2(string id, int? count, bool? includeNotPresent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfo2Response> GetArtistInfo2Async(string id, int? count, bool? includeNotPresent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfo2Response> PostGetArtistInfo2Async(Body25 body);

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistInfo2Response PostGetArtistInfo2(Body25 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistInfo2Response> PostGetArtistInfo2Async(Body25 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistsResponse> GetArtistsAsync(string musicFolderId);

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistsResponse GetArtists(string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistsResponse> GetArtistsAsync(string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistsResponse> PostGetArtistsAsync(Body26 body);

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetArtistsResponse PostGetArtists(Body26 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetArtistsResponse> PostGetArtistsAsync(Body26 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetAvatarAsync(string username);

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse GetAvatar(string username);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetAvatarAsync(string username, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetAvatarAsync(Body27 body);

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse PostGetAvatar(Body27 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetAvatarAsync(Body27 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetBookmarksResponse> GetBookmarksAsync();

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetBookmarksResponse GetBookmarks();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetBookmarksResponse> GetBookmarksAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetBookmarksResponse> PostGetBookmarksAsync(object body);

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetBookmarksResponse PostGetBookmarks(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetBookmarksResponse> PostGetBookmarksAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetCaptionsAsync(string id, Format? format);

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse GetCaptions(string id, Format? format);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetCaptionsAsync(string id, Format? format, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetCaptionsAsync(Body28 body);

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse PostGetCaptions(Body28 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetCaptionsAsync(Body28 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetChatMessagesResponse> GetChatMessagesAsync();

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetChatMessagesResponse GetChatMessages();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetChatMessagesResponse> GetChatMessagesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetChatMessagesResponse> PostGetChatMessagesAsync(object body);

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetChatMessagesResponse PostGetChatMessages(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetChatMessagesResponse> PostGetChatMessagesAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetCoverArtAsync(string id, int? size);

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse GetCoverArt(string id, int? size);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> GetCoverArtAsync(string id, int? size, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetCoverArtAsync(Body29 body);

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse PostGetCoverArt(Body29 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostGetCoverArtAsync(Body29 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetGenresResponse> GetGenresAsync();

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetGenresResponse GetGenres();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetGenresResponse> GetGenresAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetGenresResponse> PostGetGenresAsync(object body);

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetGenresResponse PostGetGenres(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetGenresResponse> PostGetGenresAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIndexesResponse> GetIndexesAsync(string musicFolderId, int? ifModifiedSince);

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetIndexesResponse GetIndexes(string musicFolderId, int? ifModifiedSince);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIndexesResponse> GetIndexesAsync(string musicFolderId, int? ifModifiedSince, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIndexesResponse> PostGetIndexesAsync(Body30 body);

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetIndexesResponse PostGetIndexes(Body30 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetIndexesResponse> PostGetIndexesAsync(Body30 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetInternetRadioStationsResponse> GetInternetRadioStationsAsync();

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetInternetRadioStationsResponse GetInternetRadioStations();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetInternetRadioStationsResponse> GetInternetRadioStationsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetInternetRadioStationsResponse> PostGetInternetRadioStationsAsync(object body);

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetInternetRadioStationsResponse PostGetInternetRadioStations(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetInternetRadioStationsResponse> PostGetInternetRadioStationsAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLicenseResponse> GetLicenseAsync();

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLicenseResponse GetLicense();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLicenseResponse> GetLicenseAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLicenseResponse> PostGetLicenseAsync(object body);

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLicenseResponse PostGetLicense(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLicenseResponse> PostGetLicenseAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsResponse> GetLyricsAsync(string artist, string title);

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLyricsResponse GetLyrics(string artist, string title);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsResponse> GetLyricsAsync(string artist, string title, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsResponse> PostGetLyricsAsync(Body31 body);

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLyricsResponse PostGetLyrics(Body31 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsResponse> PostGetLyricsAsync(Body31 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsBySongIdResponse> GetLyricsBySongIdAsync(string id);

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLyricsBySongIdResponse GetLyricsBySongId(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsBySongIdResponse> GetLyricsBySongIdAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsBySongIdResponse> PostGetLyricsBySongIdAsync(Body32 body);

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetLyricsBySongIdResponse PostGetLyricsBySongId(Body32 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetLyricsBySongIdResponse> PostGetLyricsBySongIdAsync(Body32 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicDirectoryResponse> GetMusicDirectoryAsync(string id);

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetMusicDirectoryResponse GetMusicDirectory(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicDirectoryResponse> GetMusicDirectoryAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicDirectoryResponse> PostGetMusicDirectoryAsync(Body33 body);

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetMusicDirectoryResponse PostGetMusicDirectory(Body33 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicDirectoryResponse> PostGetMusicDirectoryAsync(Body33 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicFoldersResponse> GetMusicFoldersAsync();

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetMusicFoldersResponse GetMusicFolders();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicFoldersResponse> GetMusicFoldersAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicFoldersResponse> PostGetMusicFoldersAsync(object body);

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetMusicFoldersResponse PostGetMusicFolders(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetMusicFoldersResponse> PostGetMusicFoldersAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNewestPodcastsResponse> GetNewestPodcastsAsync(int? count);

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetNewestPodcastsResponse GetNewestPodcasts(int? count);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNewestPodcastsResponse> GetNewestPodcastsAsync(int? count, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNewestPodcastsResponse> PostGetNewestPodcastsAsync(Body34 body);

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetNewestPodcastsResponse PostGetNewestPodcasts(Body34 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNewestPodcastsResponse> PostGetNewestPodcastsAsync(Body34 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNowPlayingResponse> GetNowPlayingAsync();

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetNowPlayingResponse GetNowPlaying();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNowPlayingResponse> GetNowPlayingAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNowPlayingResponse> PostGetNowPlayingAsync(object body);

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetNowPlayingResponse PostGetNowPlaying(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetNowPlayingResponse> PostGetNowPlayingAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> GetOpenSubsonicExtensionsAsync();

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetOpenSubsonicExtensionsResponse GetOpenSubsonicExtensions();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> GetOpenSubsonicExtensionsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> PostGetOpenSubsonicExtensionsAsync(object body);

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetOpenSubsonicExtensionsResponse PostGetOpenSubsonicExtensions(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> PostGetOpenSubsonicExtensionsAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistResponse> GetPlaylistAsync(string id);

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlaylistResponse GetPlaylist(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistResponse> GetPlaylistAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistResponse> PostGetPlaylistAsync(Body35 body);

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlaylistResponse PostGetPlaylist(Body35 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistResponse> PostGetPlaylistAsync(Body35 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistsResponse> GetPlaylistsAsync(string username);

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlaylistsResponse GetPlaylists(string username);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistsResponse> GetPlaylistsAsync(string username, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistsResponse> PostGetPlaylistsAsync(Body36 body);

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlaylistsResponse PostGetPlaylists(Body36 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlaylistsResponse> PostGetPlaylistsAsync(Body36 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueResponse> GetPlayQueueAsync();

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlayQueueResponse GetPlayQueue();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueResponse> GetPlayQueueAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueResponse> PostGetPlayQueueAsync(object body);

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlayQueueResponse PostGetPlayQueue(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueResponse> PostGetPlayQueueAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> GetPlayQueueByIndexAsync();

        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlayQueueByIndexResponse GetPlayQueueByIndex();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> GetPlayQueueByIndexAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> PostGetPlayQueueByIndexAsync(object body);

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPlayQueueByIndexResponse PostGetPlayQueueByIndex(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> PostGetPlayQueueByIndexAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastEpisodeResponse> GetPodcastEpisodeAsync(string id);

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPodcastEpisodeResponse GetPodcastEpisode(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastEpisodeResponse> GetPodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastEpisodeResponse> PostGetPodcastEpisodeAsync(Body37 body);

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPodcastEpisodeResponse PostGetPodcastEpisode(Body37 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastEpisodeResponse> PostGetPodcastEpisodeAsync(Body37 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastsResponse> GetPodcastsAsync(string id, bool? includeEpisodes);

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPodcastsResponse GetPodcasts(string id, bool? includeEpisodes);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastsResponse> GetPodcastsAsync(string id, bool? includeEpisodes, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastsResponse> PostGetPodcastsAsync(Body38 body);

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetPodcastsResponse PostGetPodcasts(Body38 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetPodcastsResponse> PostGetPodcastsAsync(Body38 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetRandomSongsResponse> GetRandomSongsAsync(int? size, string genre, int? fromYear, int? toYear, string musicFolderId);

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetRandomSongsResponse GetRandomSongs(int? size, string genre, int? fromYear, int? toYear, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetRandomSongsResponse> GetRandomSongsAsync(int? size, string genre, int? fromYear, int? toYear, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetRandomSongsResponse> PostGetRandomSongsAsync(Body39 body);

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetRandomSongsResponse PostGetRandomSongs(Body39 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetRandomSongsResponse> PostGetRandomSongsAsync(Body39 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetScanStatusResponse> GetScanStatusAsync();

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetScanStatusResponse GetScanStatus();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetScanStatusResponse> GetScanStatusAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetScanStatusResponse> PostGetScanStatusAsync(object body);

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetScanStatusResponse PostGetScanStatus(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetScanStatusResponse> PostGetScanStatusAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSharesResponse> GetSharesAsync();

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSharesResponse GetShares();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSharesResponse> GetSharesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSharesResponse> PostGetSharesAsync(object body);

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSharesResponse PostGetShares(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSharesResponse> PostGetSharesAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongsResponse> GetSimilarSongsAsync(string id, int? count);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSimilarSongsResponse GetSimilarSongs(string id, int? count);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongsResponse> GetSimilarSongsAsync(string id, int? count, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongsResponse> PostGetSimilarSongsAsync(Body40 body);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSimilarSongsResponse PostGetSimilarSongs(Body40 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongsResponse> PostGetSimilarSongsAsync(Body40 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongs2Response> GetSimilarSongs2Async(string id, int? count);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSimilarSongs2Response GetSimilarSongs2(string id, int? count);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongs2Response> GetSimilarSongs2Async(string id, int? count, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongs2Response> PostGetSimilarSongs2Async(Body41 body);

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSimilarSongs2Response PostGetSimilarSongs2(Body41 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSimilarSongs2Response> PostGetSimilarSongs2Async(Body41 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongResponse> GetSongAsync(string id);

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSongResponse GetSong(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongResponse> GetSongAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongResponse> PostGetSongAsync(Body42 body);

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSongResponse PostGetSong(Body42 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongResponse> PostGetSongAsync(Body42 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongsByGenreResponse> GetSongsByGenreAsync(string genre, int? count, int? offset, string musicFolderId);

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSongsByGenreResponse GetSongsByGenre(string genre, int? count, int? offset, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongsByGenreResponse> GetSongsByGenreAsync(string genre, int? count, int? offset, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongsByGenreResponse> PostGetSongsByGenreAsync(Body43 body);

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetSongsByGenreResponse PostGetSongsByGenre(Body43 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetSongsByGenreResponse> PostGetSongsByGenreAsync(Body43 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarredResponse> GetStarredAsync(string musicFolderId);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetStarredResponse GetStarred(string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarredResponse> GetStarredAsync(string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarredResponse> PostGetStarredAsync(object body);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetStarredResponse PostGetStarred(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarredResponse> PostGetStarredAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarred2Response> GetStarred2Async(string musicFolderId);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetStarred2Response GetStarred2(string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarred2Response> GetStarred2Async(string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarred2Response> PostGetStarred2Async(object body);

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetStarred2Response PostGetStarred2(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetStarred2Response> PostGetStarred2Async(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTopSongsResponse> GetTopSongsAsync(string id, int? count);

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetTopSongsResponse GetTopSongs(string id, int? count);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTopSongsResponse> GetTopSongsAsync(string id, int? count, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTopSongsResponse> PostGetTopSongsAsync(Body44 body);

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetTopSongsResponse PostGetTopSongs(Body44 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTopSongsResponse> PostGetTopSongsAsync(Body44 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserResponse> GetUserAsync(string username);

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetUserResponse GetUser(string username);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserResponse> GetUserAsync(string username, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserResponse> PostGetUserAsync(Body45 body);

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetUserResponse PostGetUser(Body45 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserResponse> PostGetUserAsync(Body45 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUsersResponse> GetUsersAsync();

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetUsersResponse GetUsers();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUsersResponse> GetUsersAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUsersResponse> PostGetUsersAsync(object body);

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetUsersResponse PostGetUsers(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUsersResponse> PostGetUsersAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideoInfoResponse> GetVideoInfoAsync(string id);

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetVideoInfoResponse GetVideoInfo(string id);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideoInfoResponse> GetVideoInfoAsync(string id, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideoInfoResponse> PostGetVideoInfoAsync(Body46 body);

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetVideoInfoResponse PostGetVideoInfo(Body46 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideoInfoResponse> PostGetVideoInfoAsync(Body46 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideosResponse> GetVideosAsync();

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetVideosResponse GetVideos();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideosResponse> GetVideosAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideosResponse> PostGetVideosAsync(object body);

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetVideosResponse PostGetVideos(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetVideosResponse> PostGetVideosAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Hls_m3u8Async(string id, int? bitRate, string audioTrack);

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        string Hls_m3u8(string id, int? bitRate, string audioTrack);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Hls_m3u8Async(string id, int? bitRate, string audioTrack, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> PostHls_m3u8Async(Body47 body);

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        string PostHls_m3u8(Body47 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> PostHls_m3u8Async(Body47 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JukeboxControlResponse> JukeboxControlAsync(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain);

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        JukeboxControlResponse JukeboxControl(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JukeboxControlResponse> JukeboxControlAsync(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JukeboxControlResponse> PostJukeboxControlAsync(Body48 body);

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        JukeboxControlResponse PostJukeboxControl(Body48 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<JukeboxControlResponse> PostJukeboxControlAsync(Body48 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PingAsync();

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse Ping();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PingAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostPingAsync(object body);

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostPing(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostPingAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> RefreshPodcastsAsync();

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse RefreshPodcasts();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> RefreshPodcastsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostRefreshPodcastsAsync(object body);

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostRefreshPodcasts(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostRefreshPodcastsAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueAsync(string id, string current, int? position);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse SavePlayQueue(string id, string current, int? position);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueAsync(string id, string current, int? position, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueAsync(Body49 body);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostSavePlayQueue(Body49 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueAsync(Body49 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueByIndexAsync(string id, int? currentIndex, int? position);

        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse SavePlayQueueByIndex(string id, int? currentIndex, int? position);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueByIndexAsync(string id, int? currentIndex, int? position, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueByIndexAsync(Body50 body);

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostSavePlayQueueByIndex(Body50 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueByIndexAsync(Body50 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> ScrobbleAsync(string id, int? time, bool? submission);

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse Scrobble(string id, int? time, bool? submission);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> ScrobbleAsync(string id, int? time, bool? submission, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostScrobbleAsync(Body51 body);

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostScrobble(Body51 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostScrobbleAsync(Body51 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SearchResponse> SearchAsync(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        SearchResponse Search(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SearchResponse> SearchAsync(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SearchResponse> PostSearchAsync(Body52 body);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        SearchResponse PostSearch(Body52 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SearchResponse> PostSearchAsync(Body52 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search2Response> Search2Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        Search2Response Search2(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search2Response> Search2Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search2Response> PostSearch2Async(Body53 body);

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        Search2Response PostSearch2(Body53 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search2Response> PostSearch2Async(Body53 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search3Response> Search3Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId);

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        Search3Response Search3(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search3Response> Search3Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search3Response> PostSearch3Async(Body54 body);

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        Search3Response PostSearch3(Body54 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Search3Response> PostSearch3Async(Body54 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SetRatingAsync(string id, int rating);

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse SetRating(string id, int rating);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> SetRatingAsync(string id, int rating, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSetRatingAsync(Body55 body);

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostSetRating(Body55 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostSetRatingAsync(Body55 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> StarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId);

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse Star(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> StarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostStarAsync(Body56 body);

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostStar(Body56 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostStarAsync(Body56 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StartScanResponse> StartScanAsync();

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        StartScanResponse StartScan();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StartScanResponse> StartScanAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StartScanResponse> PostStartScanAsync(object body);

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        StartScanResponse PostStartScan(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StartScanResponse> PostStartScanAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> StreamAsync(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted);

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse Stream(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> StreamAsync(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostStreamAsync(Body57 body);

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        FileResponse PostStream(Body57 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> PostStreamAsync(Body57 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTokenInfoResponse> TokenInfoAsync();

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetTokenInfoResponse TokenInfo();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTokenInfoResponse> TokenInfoAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTokenInfoResponse> PostTokenInfoAsync(object body);

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        GetTokenInfoResponse PostTokenInfo(object body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetTokenInfoResponse> PostTokenInfoAsync(object body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UnstarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId);

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse Unstar(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UnstarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUnstarAsync(Body58 body);

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostUnstar(Body58 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUnstarAsync(Body58 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateInternetRadioStationAsync(string id, string streamUrl, string name, string homepageUrl);

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse UpdateInternetRadioStation(string id, string streamUrl, string name, string homepageUrl);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateInternetRadioStationAsync(string id, string streamUrl, string name, string homepageUrl, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateInternetRadioStationAsync(Body59 body);

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostUpdateInternetRadioStation(Body59 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateInternetRadioStationAsync(Body59 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdatePlaylistAsync(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove);

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse UpdatePlaylist(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdatePlaylistAsync(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdatePlaylistAsync(Body60 body);

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostUpdatePlaylist(Body60 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdatePlaylistAsync(Body60 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateShareAsync(string id, string description, int? expires);

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse UpdateShare(string id, string description, int? expires);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateShareAsync(string id, string description, int? expires, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateShareAsync(Body61 body);

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostUpdateShare(Body61 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateShareAsync(Body61 body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate);

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse UpdateUser(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> UpdateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateUserAsync(Body62 body);

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        SubsonicResponse PostUpdateUser(Body62 body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubsonicResponse> PostUpdateUserAsync(Body62 body, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Client : IClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);
        private Newtonsoft.Json.JsonSerializerSettings _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public Client(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "{url}";
            _httpClient = httpClient;
            Initialize();
        }

        private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> GetAddChatMessageAsync(string message)
        {
            return GetAddChatMessageAsync(message, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse GetAddChatMessage(string message)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAddChatMessageAsync(message, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// </remarks>
        /// <param name="message">The chat message.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> GetAddChatMessageAsync(string message, System.Threading.CancellationToken cancellationToken)
        {
            if (message == null)
                throw new System.ArgumentNullException("message");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/addChatMessage"
                    urlBuilder_.Append("rest/addChatMessage");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("message")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(message, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostAddChatMessageAsync(Body body)
        {
            return PostAddChatMessageAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostAddChatMessage(Body body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostAddChatMessageAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a message to the chat log.
        /// </summary>
        /// <remarks>
        /// Adds a message to the chat log.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostAddChatMessageAsync(Body body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/addChatMessage"
                    urlBuilder_.Append("rest/addChatMessage");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> ChangePasswordAsync(string username, string password)
        {
            return ChangePasswordAsync(username, password, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse ChangePassword(string username, string password)
        {
            return System.Threading.Tasks.Task.Run(async () => await ChangePasswordAsync(username, password, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// </remarks>
        /// <param name="username">The name of the user which should change its password.</param>
        /// <param name="password">The new password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> ChangePasswordAsync(string username, string password, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            if (password == null)
                throw new System.ArgumentNullException("password");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/changePassword"
                    urlBuilder_.Append("rest/changePassword");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("password")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(password, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostChangePasswordAsync(Body2 body)
        {
            return PostChangePasswordAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostChangePassword(Body2 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostChangePasswordAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Changes the password of an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Changes the password of an existing user on the server, using the following parameters. You can only change your own password unless you have admin privileges.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostChangePasswordAsync(Body2 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/changePassword"
                    urlBuilder_.Append("rest/changePassword");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> CreateBookmarkAsync(string id, int position, string comment)
        {
            return CreateBookmarkAsync(id, position, comment, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse CreateBookmark(string id, int position, string comment)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreateBookmarkAsync(id, position, comment, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.</param>
        /// <param name="position">The position (in milliseconds) within the media file.</param>
        /// <param name="comment">A user-defined comment.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> CreateBookmarkAsync(string id, int position, string comment, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (position == null)
                throw new System.ArgumentNullException("position");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createBookmark"
                    urlBuilder_.Append("rest/createBookmark");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("position")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(position, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (comment != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("comment")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(comment, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostCreateBookmarkAsync(Body3 body)
        {
            return PostCreateBookmarkAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostCreateBookmark(Body3 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreateBookmarkAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates or updates a bookmark.
        /// </summary>
        /// <remarks>
        /// Creates or updates a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostCreateBookmarkAsync(Body3 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createBookmark"
                    urlBuilder_.Append("rest/createBookmark");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> CreateInternetRadioStationAsync(string streamUrl, string name, string homepageUrl)
        {
            return CreateInternetRadioStationAsync(streamUrl, name, homepageUrl, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse CreateInternetRadioStation(string streamUrl, string name, string homepageUrl)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreateInternetRadioStationAsync(streamUrl, name, homepageUrl, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The station name.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> CreateInternetRadioStationAsync(string streamUrl, string name, string homepageUrl, System.Threading.CancellationToken cancellationToken)
        {
            if (streamUrl == null)
                throw new System.ArgumentNullException("streamUrl");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createInternetRadioStation"
                    urlBuilder_.Append("rest/createInternetRadioStation");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("streamUrl")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(streamUrl, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (homepageUrl != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("homepageUrl")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(homepageUrl, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostCreateInternetRadioStationAsync(Body4 body)
        {
            return PostCreateInternetRadioStationAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostCreateInternetRadioStation(Body4 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreateInternetRadioStationAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new internet radio station.
        /// </summary>
        /// <remarks>
        /// Adds a new internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostCreateInternetRadioStationAsync(Body4 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createInternetRadioStation"
                    urlBuilder_.Append("rest/createInternetRadioStation");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CreatePlaylistResponse> CreatePlaylistAsync(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId)
        {
            return CreatePlaylistAsync(playlistId, name, songId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual CreatePlaylistResponse CreatePlaylist(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreatePlaylistAsync(playlistId, name, songId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// </remarks>
        /// <param name="playlistId">The playlist ID. Required if updating an existing playlist.</param>
        /// <param name="name">The human-readable name of the playlist. Required if creating a new playlist.</param>
        /// <param name="songId">ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CreatePlaylistResponse> CreatePlaylistAsync(string playlistId, string name, System.Collections.Generic.IEnumerable<string> songId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createPlaylist"
                    urlBuilder_.Append("rest/createPlaylist");
                    urlBuilder_.Append('?');
                    if (playlistId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("playlistId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(playlistId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songId != null)
                    {
                            foreach (var item_ in songId) { urlBuilder_.Append(System.Uri.EscapeDataString("songId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreatePlaylistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CreatePlaylistResponse> PostCreatePlaylistAsync(Body5 body)
        {
            return PostCreatePlaylistAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual CreatePlaylistResponse PostCreatePlaylist(Body5 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreatePlaylistAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates (or updates) a playlist.
        /// </summary>
        /// <remarks>
        /// Creates (or updates) a playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CreatePlaylistResponse> PostCreatePlaylistAsync(Body5 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createPlaylist"
                    urlBuilder_.Append("rest/createPlaylist");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreatePlaylistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> CreatePodcastChannelAsync(string url)
        {
            return CreatePodcastChannelAsync(url, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse CreatePodcastChannel(string url)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreatePodcastChannelAsync(url, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="url">The URL of the Podcast to add.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> CreatePodcastChannelAsync(string url, System.Threading.CancellationToken cancellationToken)
        {
            if (url == null)
                throw new System.ArgumentNullException("url");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createPodcastChannel"
                    urlBuilder_.Append("rest/createPodcastChannel");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("url")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(url, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostCreatePodcastChannelAsync(Body6 body)
        {
            return PostCreatePodcastChannelAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostCreatePodcastChannel(Body6 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreatePodcastChannelAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Adds a new Podcast channel.
        /// </summary>
        /// <remarks>
        /// Adds a new Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostCreatePodcastChannelAsync(Body6 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createPodcastChannel"
                    urlBuilder_.Append("rest/createPodcastChannel");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CreateSharesResponse> CreateShareAsync(System.Collections.Generic.IEnumerable<string> id, string description, int? expires)
        {
            return CreateShareAsync(id, description, expires, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual CreateSharesResponse CreateShare(System.Collections.Generic.IEnumerable<string> id, string description, int? expires)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreateShareAsync(id, description, expires, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// </remarks>
        /// <param name="id">ID of a song, album or video to share. Use one id parameter for each entry to share.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CreateSharesResponse> CreateShareAsync(System.Collections.Generic.IEnumerable<string> id, string description, int? expires, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createShare"
                    urlBuilder_.Append("rest/createShare");
                    urlBuilder_.Append('?');
                        foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    if (description != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("description")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(description, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (expires != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("expires")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(expires, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateSharesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CreateSharesResponse> PostCreateShareAsync(Body7 body)
        {
            return PostCreateShareAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual CreateSharesResponse PostCreateShare(Body7 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreateShareAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a public URL that can be used by anyone to stream music or video from the server.
        /// </summary>
        /// <remarks>
        /// Creates a public URL that can be used by anyone to stream music or video from the server. The URL is short and suitable for posting on Facebook, Twitter etc. Note: The user must be authorized to share (see Settings &gt; Users &gt; User is allowed to share files with anyone). Since 1.6.0.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CreateSharesResponse> PostCreateShareAsync(Body7 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createShare"
                    urlBuilder_.Append("rest/createShare");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateSharesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> CreateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId)
        {
            return CreateUserAsync(username, password, email, ldapAuthenticated, adminRole, settingsRole, streamRole, jukeboxRole, downloadRole, uploadRole, playlistRole, coverArtRole, commentRole, podcastRole, shareRole, videoConversionRole, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse CreateUser(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await CreateUserAsync(username, password, email, ldapAuthenticated, adminRole, settingsRole, streamRole, jukeboxRole, downloadRole, uploadRole, playlistRole, coverArtRole, commentRole, podcastRole, shareRole, videoConversionRole, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// </remarks>
        /// <param name="username">The name of the new user.</param>
        /// <param name="password">The password of the new user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the new user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenticated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="playlistRole">Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">(Since 1.8.0) Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> CreateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? playlistRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            if (password == null)
                throw new System.ArgumentNullException("password");

            if (email == null)
                throw new System.ArgumentNullException("email");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createUser"
                    urlBuilder_.Append("rest/createUser");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("password")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(password, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("email")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(email, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (ldapAuthenticated != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ldapAuthenticated")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(ldapAuthenticated, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (adminRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("adminRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(adminRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (settingsRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("settingsRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(settingsRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (streamRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("streamRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(streamRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (jukeboxRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("jukeboxRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(jukeboxRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (downloadRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("downloadRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(downloadRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (uploadRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("uploadRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(uploadRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (playlistRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("playlistRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(playlistRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (coverArtRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("coverArtRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coverArtRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (commentRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("commentRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(commentRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (podcastRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("podcastRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(podcastRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (shareRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("shareRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(shareRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (videoConversionRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("videoConversionRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(videoConversionRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                            foreach (var item_ in musicFolderId) { urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostCreateUserAsync(Body8 body)
        {
            return PostCreateUserAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostCreateUser(Body8 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostCreateUserAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a new user on the server.
        /// </summary>
        /// <remarks>
        /// Creates a new user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostCreateUserAsync(Body8 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/createUser"
                    urlBuilder_.Append("rest/createUser");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeleteBookmarkAsync(string id)
        {
            return DeleteBookmarkAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeleteBookmark(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeleteBookmarkAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// </remarks>
        /// <param name="id">ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeleteBookmarkAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteBookmark"
                    urlBuilder_.Append("rest/deleteBookmark");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeleteBookmarkAsync(Body9 body)
        {
            return PostDeleteBookmarkAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeleteBookmark(Body9 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeleteBookmarkAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a bookmark.
        /// </summary>
        /// <remarks>
        /// Deletes a bookmark (a position within a media file). Bookmarks are personal and not visible to other users.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeleteBookmarkAsync(Body9 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteBookmark"
                    urlBuilder_.Append("rest/deleteBookmark");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeleteInternetRadioStationAsync(string id)
        {
            return DeleteInternetRadioStationAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeleteInternetRadioStation(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeleteInternetRadioStationAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeleteInternetRadioStationAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteInternetRadioStation"
                    urlBuilder_.Append("rest/deleteInternetRadioStation");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeleteInternetRadioStationAsync(Body10 body)
        {
            return PostDeleteInternetRadioStationAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeleteInternetRadioStation(Body10 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeleteInternetRadioStationAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Deletes an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeleteInternetRadioStationAsync(Body10 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteInternetRadioStation"
                    urlBuilder_.Append("rest/deleteInternetRadioStation");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeletePlaylistAsync(string id)
        {
            return DeletePlaylistAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeletePlaylist(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeletePlaylistAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to delete, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeletePlaylistAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePlaylist"
                    urlBuilder_.Append("rest/deletePlaylist");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeletePlaylistAsync(Body11 body)
        {
            return PostDeletePlaylistAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeletePlaylist(Body11 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeletePlaylistAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a saved playlist.
        /// </summary>
        /// <remarks>
        /// Deletes a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeletePlaylistAsync(Body11 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePlaylist"
                    urlBuilder_.Append("rest/deletePlaylist");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastChannelAsync(string id)
        {
            return DeletePodcastChannelAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeletePodcastChannel(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeletePodcastChannelAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast channel to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastChannelAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePodcastChannel"
                    urlBuilder_.Append("rest/deletePodcastChannel");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastChannelAsync(Body12 body)
        {
            return PostDeletePodcastChannelAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeletePodcastChannel(Body12 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeletePodcastChannelAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast channel.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast channel. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastChannelAsync(Body12 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePodcastChannel"
                    urlBuilder_.Append("rest/deletePodcastChannel");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastEpisodeAsync(string id)
        {
            return DeletePodcastEpisodeAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeletePodcastEpisode(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeletePodcastEpisodeAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeletePodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePodcastEpisode"
                    urlBuilder_.Append("rest/deletePodcastEpisode");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastEpisodeAsync(Body13 body)
        {
            return PostDeletePodcastEpisodeAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeletePodcastEpisode(Body13 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeletePodcastEpisodeAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a Podcast episode.
        /// </summary>
        /// <remarks>
        /// Deletes a Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeletePodcastEpisodeAsync(Body13 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deletePodcastEpisode"
                    urlBuilder_.Append("rest/deletePodcastEpisode");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeleteShareAsync(string id)
        {
            return DeleteShareAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeleteShare(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeleteShareAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share
        /// </remarks>
        /// <param name="id">ID of the share to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeleteShareAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteShare"
                    urlBuilder_.Append("rest/deleteShare");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeleteShareAsync(Body14 body)
        {
            return PostDeleteShareAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeleteShare(Body14 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeleteShareAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing share.
        /// </summary>
        /// <remarks>
        /// Deletes an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeleteShareAsync(Body14 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteShare"
                    urlBuilder_.Append("rest/deleteShare");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DeleteUserAsync(string username)
        {
            return DeleteUserAsync(username, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DeleteUser(string username)
        {
            return System.Threading.Tasks.Task.Run(async () => await DeleteUserAsync(username, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user to delete.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DeleteUserAsync(string username, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteUser"
                    urlBuilder_.Append("rest/deleteUser");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDeleteUserAsync(Body15 body)
        {
            return PostDeleteUserAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDeleteUser(Body15 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDeleteUserAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Deletes an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDeleteUserAsync(Body15 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/deleteUser"
                    urlBuilder_.Append("rest/deleteUser");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> DownloadAsync(string id)
        {
            return DownloadAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse Download(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DownloadAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> DownloadAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/download"
                    urlBuilder_.Append("rest/download");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> PostDownloadAsync(Body16 body)
        {
            return PostDownloadAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse PostDownload(Body16 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDownloadAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file.
        /// </summary>
        /// <remarks>
        /// Downloads a given media file. Similar to stream, but this method returns the original media data without transcoding or downsampling.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> PostDownloadAsync(Body16 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/download"
                    urlBuilder_.Append("rest/download");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> DownloadPodcastEpisodeAsync(string id)
        {
            return DownloadPodcastEpisodeAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse DownloadPodcastEpisode(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await DownloadPodcastEpisodeAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <param name="id">The ID of the Podcast episode to download</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> DownloadPodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/downloadPodcastEpisode"
                    urlBuilder_.Append("rest/downloadPodcastEpisode");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostDownloadPodcastEpisodeAsync(Body17 body)
        {
            return PostDownloadPodcastEpisodeAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostDownloadPodcastEpisode(Body17 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostDownloadPodcastEpisodeAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request the server to start downloading a given Podcast episode.
        /// </summary>
        /// <remarks>
        /// Request the server to start downloading a given Podcast episode. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostDownloadPodcastEpisodeAsync(Body17 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/downloadPodcastEpisode"
                    urlBuilder_.Append("rest/downloadPodcastEpisode");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumResponse> GetAlbumAsync(string id)
        {
            return GetAlbumAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumResponse GetAlbum(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAlbumAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumResponse> GetAlbumAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbum"
                    urlBuilder_.Append("rest/getAlbum");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumResponse> PostGetAlbumAsync(Body18 body)
        {
            return PostGetAlbumAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumResponse PostGetAlbum(Body18 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAlbumAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an album.
        /// </summary>
        /// <remarks>
        /// Returns details for an album, including a list of songs. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumResponse> PostGetAlbumAsync(Body18 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbum"
                    urlBuilder_.Append("rest/getAlbum");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfoAsync(string id)
        {
            return GetAlbumInfoAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumInfoResponse GetAlbumInfo(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAlbumInfoAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfoAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumInfo"
                    urlBuilder_.Append("rest/getAlbumInfo");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfoAsync(Body19 body)
        {
            return PostGetAlbumInfoAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumInfoResponse PostGetAlbumInfo(Body19 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAlbumInfoAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info.
        /// </summary>
        /// <remarks>
        /// Returns album notes, image URLs etc, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfoAsync(Body19 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumInfo"
                    urlBuilder_.Append("rest/getAlbumInfo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfo2Async(string id)
        {
            return GetAlbumInfo2Async(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumInfoResponse GetAlbumInfo2(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAlbumInfo2Async(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The album ID or song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumInfoResponse> GetAlbumInfo2Async(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumInfo2"
                    urlBuilder_.Append("rest/getAlbumInfo2");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfo2Async(Body20 body)
        {
            return PostGetAlbumInfo2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumInfoResponse PostGetAlbumInfo2(Body20 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAlbumInfo2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns album info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to getAlbumInfo, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumInfoResponse> PostGetAlbumInfo2Async(Body20 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumInfo2"
                    urlBuilder_.Append("rest/getAlbumInfo2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumListResponse> GetAlbumListAsync(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId)
        {
            return GetAlbumListAsync(type, size, offset, fromYear, toYear, genre, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumListResponse GetAlbumList(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAlbumListAsync(type, size, offset, fromYear, toYear, genre, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumListResponse> GetAlbumListAsync(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumList"
                    urlBuilder_.Append("rest/getAlbumList");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (fromYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("fromYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(fromYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (toYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("toYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(toYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (genre != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("genre")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(genre, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumListResponse> PostGetAlbumListAsync(Body21 body)
        {
            return PostGetAlbumListAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumListResponse PostGetAlbumList(Body21 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAlbumListAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums.
        /// </summary>
        /// <remarks>
        /// Returns a list of random, newest, highest rated etc. albums. Similar to the album lists on the home page of the Subsonic web interface.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumListResponse> PostGetAlbumListAsync(Body21 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumList"
                    urlBuilder_.Append("rest/getAlbumList");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumList2Response> GetAlbumList2Async(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId)
        {
            return GetAlbumList2Async(type, size, offset, fromYear, toYear, genre, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumList2Response GetAlbumList2(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAlbumList2Async(type, size, offset, fromYear, toYear, genre, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="size">The number of albums to return. Max 500.</param>
        /// <param name="offset">The list offset. Useful if you for example want to page through the list of newest albums.</param>
        /// <param name="fromYear">Required if `type=='byYear'`. The first year in the range. If `fromYear` &gt; `toYear` a reverse chronological list is returned.</param>
        /// <param name="toYear">Required if `type=='byYear'`. The last year in the range.</param>
        /// <param name="genre">Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.</param>
        /// <param name="musicFolderId">(Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumList2Response> GetAlbumList2Async(AlbumListType type, int? size, int? offset, int? fromYear, int? toYear, string genre, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumList2"
                    urlBuilder_.Append("rest/getAlbumList2");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (fromYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("fromYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(fromYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (toYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("toYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(toYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (genre != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("genre")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(genre, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumList2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetAlbumList2Response> PostGetAlbumList2Async(Body22 body)
        {
            return PostGetAlbumList2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetAlbumList2Response PostGetAlbumList2(Body22 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAlbumList2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a list of random, newest, highest rated etc. albums (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getAlbumList`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetAlbumList2Response> PostGetAlbumList2Async(Body22 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAlbumList2"
                    urlBuilder_.Append("rest/getAlbumList2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetAlbumList2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistResponse> GetArtistAsync(string id)
        {
            return GetArtistAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistResponse GetArtist(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetArtistAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistResponse> GetArtistAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtist"
                    urlBuilder_.Append("rest/getArtist");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistResponse> PostGetArtistAsync(Body23 body)
        {
            return PostGetArtistAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistResponse PostGetArtist(Body23 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetArtistAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for an artist.
        /// </summary>
        /// <remarks>
        /// Returns details for an artist, including a list of albums. This method organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistResponse> PostGetArtistAsync(Body23 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtist"
                    urlBuilder_.Append("rest/getArtist");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistInfoResponse> GetArtistInfoAsync(string id, int? count, bool? includeNotPresent)
        {
            return GetArtistInfoAsync(id, count, includeNotPresent, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistInfoResponse GetArtistInfo(string id, int? count, bool? includeNotPresent)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetArtistInfoAsync(id, count, includeNotPresent, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistInfoResponse> GetArtistInfoAsync(string id, int? count, bool? includeNotPresent, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtistInfo"
                    urlBuilder_.Append("rest/getArtistInfo");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (includeNotPresent != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("includeNotPresent")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeNotPresent, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistInfoResponse> PostGetArtistInfoAsync(Body24 body)
        {
            return PostGetArtistInfoAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistInfoResponse PostGetArtistInfo(Body24 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetArtistInfoAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info.
        /// </summary>
        /// <remarks>
        /// Returns artist info with biography, image URLs and similar artists, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistInfoResponse> PostGetArtistInfoAsync(Body24 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtistInfo"
                    urlBuilder_.Append("rest/getArtistInfo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistInfo2Response> GetArtistInfo2Async(string id, int? count, bool? includeNotPresent)
        {
            return GetArtistInfo2Async(id, count, includeNotPresent, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistInfo2Response GetArtistInfo2(string id, int? count, bool? includeNotPresent)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetArtistInfo2Async(id, count, includeNotPresent, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of similar artists to return.</param>
        /// <param name="includeNotPresent">Whether to return artists that are not present in the media library.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistInfo2Response> GetArtistInfo2Async(string id, int? count, bool? includeNotPresent, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtistInfo2"
                    urlBuilder_.Append("rest/getArtistInfo2");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (includeNotPresent != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("includeNotPresent")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeNotPresent, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistInfo2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistInfo2Response> PostGetArtistInfo2Async(Body25 body)
        {
            return PostGetArtistInfo2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistInfo2Response PostGetArtistInfo2(Body25 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetArtistInfo2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns artist info (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getArtistInfo`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistInfo2Response> PostGetArtistInfo2Async(Body25 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtistInfo2"
                    urlBuilder_.Append("rest/getArtistInfo2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistInfo2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistsResponse> GetArtistsAsync(string musicFolderId)
        {
            return GetArtistsAsync(musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistsResponse GetArtists(string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetArtistsAsync(musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistsResponse> GetArtistsAsync(string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtists"
                    urlBuilder_.Append("rest/getArtists");
                    urlBuilder_.Append('?');
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetArtistsResponse> PostGetArtistsAsync(Body26 body)
        {
            return PostGetArtistsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetArtistsResponse PostGetArtists(Body26 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetArtistsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getIndexes`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetArtistsResponse> PostGetArtistsAsync(Body26 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getArtists"
                    urlBuilder_.Append("rest/getArtists");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetArtistsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> GetAvatarAsync(string username)
        {
            return GetAvatarAsync(username, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse GetAvatar(string username)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetAvatarAsync(username, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> GetAvatarAsync(string username, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAvatar"
                    urlBuilder_.Append("rest/getAvatar");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> PostGetAvatarAsync(Body27 body)
        {
            return PostGetAvatarAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse PostGetAvatar(Body27 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetAvatarAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the avatar (personal image) for a user.
        /// </summary>
        /// <remarks>
        /// Returns the avatar (personal image) for a user.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> PostGetAvatarAsync(Body27 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getAvatar"
                    urlBuilder_.Append("rest/getAvatar");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetBookmarksResponse> GetBookmarksAsync()
        {
            return GetBookmarksAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetBookmarksResponse GetBookmarks()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetBookmarksAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetBookmarksResponse> GetBookmarksAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getBookmarks"
                    urlBuilder_.Append("rest/getBookmarks");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetBookmarksResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetBookmarksResponse> PostGetBookmarksAsync(object body)
        {
            return PostGetBookmarksAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetBookmarksResponse PostGetBookmarks(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetBookmarksAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all bookmarks for this user.
        /// </summary>
        /// <remarks>
        /// Returns all bookmarks for this user. A bookmark is a position within a certain media file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetBookmarksResponse> PostGetBookmarksAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getBookmarks"
                    urlBuilder_.Append("rest/getBookmarks");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetBookmarksResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> GetCaptionsAsync(string id, Format? format)
        {
            return GetCaptionsAsync(id, format, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse GetCaptions(string id, Format? format)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetCaptionsAsync(id, format, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// </remarks>
        /// <param name="id">The ID of the video.</param>
        /// <param name="format">Preferred captions format (“srt” or “vtt”).</param>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> GetCaptionsAsync(string id, Format? format, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getCaptions"
                    urlBuilder_.Append("rest/getCaptions");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var result_ = (FileResponse)System.Convert.ChangeType(responseData_, typeof(FileResponse));
                            return result_;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> PostGetCaptionsAsync(Body28 body)
        {
            return PostGetCaptionsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse PostGetCaptions(Body28 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetCaptionsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns captions (subtitles) for a video.
        /// </summary>
        /// <remarks>
        /// Returns captions (subtitles) for a video. Use `getVideoInfo` to get a list of available captions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Returns the raw video captions.</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> PostGetCaptionsAsync(Body28 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getCaptions"
                    urlBuilder_.Append("rest/getCaptions");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var result_ = (FileResponse)System.Convert.ChangeType(responseData_, typeof(FileResponse));
                            return result_;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetChatMessagesResponse> GetChatMessagesAsync()
        {
            return GetChatMessagesAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetChatMessagesResponse GetChatMessages()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetChatMessagesAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetChatMessagesResponse> GetChatMessagesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getChatMessages"
                    urlBuilder_.Append("rest/getChatMessages");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetChatMessagesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetChatMessagesResponse> PostGetChatMessagesAsync(object body)
        {
            return PostGetChatMessagesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetChatMessagesResponse PostGetChatMessages(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetChatMessagesAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current visible (non-expired) chat messages.
        /// </summary>
        /// <remarks>
        /// Returns the current visible (non-expired) chat messages.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetChatMessagesResponse> PostGetChatMessagesAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getChatMessages"
                    urlBuilder_.Append("rest/getChatMessages");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetChatMessagesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> GetCoverArtAsync(string id, int? size)
        {
            return GetCoverArtAsync(id, size, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse GetCoverArt(string id, int? size)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetCoverArtAsync(id, size, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// </remarks>
        /// <param name="id">The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`</param>
        /// <param name="size">If specified, scale image to this size.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> GetCoverArtAsync(string id, int? size, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getCoverArt"
                    urlBuilder_.Append("rest/getCoverArt");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> PostGetCoverArtAsync(Body29 body)
        {
            return PostGetCoverArtAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse PostGetCoverArt(Body29 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetCoverArtAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a cover art image.
        /// </summary>
        /// <remarks>
        /// Returns a cover art image.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> PostGetCoverArtAsync(Body29 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getCoverArt"
                    urlBuilder_.Append("rest/getCoverArt");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetGenresResponse> GetGenresAsync()
        {
            return GetGenresAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetGenresResponse GetGenres()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetGenresAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetGenresResponse> GetGenresAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getGenres"
                    urlBuilder_.Append("rest/getGenres");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetGenresResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetGenresResponse> PostGetGenresAsync(object body)
        {
            return PostGetGenresAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetGenresResponse PostGetGenres(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetGenresAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all genres.
        /// </summary>
        /// <remarks>
        /// Returns all genres.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetGenresResponse> PostGetGenresAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getGenres"
                    urlBuilder_.Append("rest/getGenres");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetGenresResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetIndexesResponse> GetIndexesAsync(string musicFolderId, int? ifModifiedSince)
        {
            return GetIndexesAsync(musicFolderId, ifModifiedSince, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetIndexesResponse GetIndexes(string musicFolderId, int? ifModifiedSince)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetIndexesAsync(musicFolderId, ifModifiedSince, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// </remarks>
        /// <param name="musicFolderId">If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <param name="ifModifiedSince">If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetIndexesResponse> GetIndexesAsync(string musicFolderId, int? ifModifiedSince, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getIndexes"
                    urlBuilder_.Append("rest/getIndexes");
                    urlBuilder_.Append('?');
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (ifModifiedSince != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ifModifiedSince")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(ifModifiedSince, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetIndexesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetIndexesResponse> PostGetIndexesAsync(Body30 body)
        {
            return PostGetIndexesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetIndexesResponse PostGetIndexes(Body30 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetIndexesAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns an indexed structure of all artists.
        /// </summary>
        /// <remarks>
        /// Returns an indexed structure of all artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetIndexesResponse> PostGetIndexesAsync(Body30 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getIndexes"
                    urlBuilder_.Append("rest/getIndexes");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetIndexesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetInternetRadioStationsResponse> GetInternetRadioStationsAsync()
        {
            return GetInternetRadioStationsAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetInternetRadioStationsResponse GetInternetRadioStations()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetInternetRadioStationsAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetInternetRadioStationsResponse> GetInternetRadioStationsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getInternetRadioStations"
                    urlBuilder_.Append("rest/getInternetRadioStations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetInternetRadioStationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetInternetRadioStationsResponse> PostGetInternetRadioStationsAsync(object body)
        {
            return PostGetInternetRadioStationsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetInternetRadioStationsResponse PostGetInternetRadioStations(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetInternetRadioStationsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all internet radio stations.
        /// </summary>
        /// <remarks>
        /// Returns all internet radio stations. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetInternetRadioStationsResponse> PostGetInternetRadioStationsAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getInternetRadioStations"
                    urlBuilder_.Append("rest/getInternetRadioStations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetInternetRadioStationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLicenseResponse> GetLicenseAsync()
        {
            return GetLicenseAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLicenseResponse GetLicense()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetLicenseAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLicenseResponse> GetLicenseAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLicense"
                    urlBuilder_.Append("rest/getLicense");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLicenseResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLicenseResponse> PostGetLicenseAsync(object body)
        {
            return PostGetLicenseAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLicenseResponse PostGetLicense(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetLicenseAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about the software license.
        /// </summary>
        /// <remarks>
        /// Get details about the software license.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLicenseResponse> PostGetLicenseAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLicense"
                    urlBuilder_.Append("rest/getLicense");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLicenseResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLyricsResponse> GetLyricsAsync(string artist, string title)
        {
            return GetLyricsAsync(artist, title, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLyricsResponse GetLyrics(string artist, string title)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetLyricsAsync(artist, title, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// </remarks>
        /// <param name="artist">The artist name.</param>
        /// <param name="title">The song title.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLyricsResponse> GetLyricsAsync(string artist, string title, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLyrics"
                    urlBuilder_.Append("rest/getLyrics");
                    urlBuilder_.Append('?');
                    if (artist != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artist")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artist, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLyricsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLyricsResponse> PostGetLyricsAsync(Body31 body)
        {
            return PostGetLyricsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLyricsResponse PostGetLyrics(Body31 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetLyricsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Searches for and returns lyrics for a given song.
        /// </summary>
        /// <remarks>
        /// Searches for and returns lyrics for a given song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLyricsResponse> PostGetLyricsAsync(Body31 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLyrics"
                    urlBuilder_.Append("rest/getLyrics");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLyricsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLyricsBySongIdResponse> GetLyricsBySongIdAsync(string id)
        {
            return GetLyricsBySongIdAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLyricsBySongIdResponse GetLyricsBySongId(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetLyricsBySongIdAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <param name="id">The track ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLyricsBySongIdResponse> GetLyricsBySongIdAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLyricsBySongId"
                    urlBuilder_.Append("rest/getLyricsBySongId");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLyricsBySongIdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetLyricsBySongIdResponse> PostGetLyricsBySongIdAsync(Body32 body)
        {
            return PostGetLyricsBySongIdAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetLyricsBySongIdResponse PostGetLyricsBySongId(Body32 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetLyricsBySongIdAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `songLyrics` (As returned by `getOpenSubsonicExtensions`). Retrieves all structured lyrics from the server for a given song. The lyrics can come from embedded tags (SYLT/USLT), LRC file/text file, or any other external source.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetLyricsBySongIdResponse> PostGetLyricsBySongIdAsync(Body32 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getLyricsBySongId"
                    urlBuilder_.Append("rest/getLyricsBySongId");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetLyricsBySongIdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetMusicDirectoryResponse> GetMusicDirectoryAsync(string id)
        {
            return GetMusicDirectoryAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetMusicDirectoryResponse GetMusicDirectory(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetMusicDirectoryAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetMusicDirectoryResponse> GetMusicDirectoryAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getMusicDirectory"
                    urlBuilder_.Append("rest/getMusicDirectory");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetMusicDirectoryResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetMusicDirectoryResponse> PostGetMusicDirectoryAsync(Body33 body)
        {
            return PostGetMusicDirectoryAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetMusicDirectoryResponse PostGetMusicDirectory(Body33 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetMusicDirectoryAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of all files in a music directory.
        /// </summary>
        /// <remarks>
        /// Returns a listing of all files in a music directory. Typically used to get list of albums for an artist, or list of songs for an album.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetMusicDirectoryResponse> PostGetMusicDirectoryAsync(Body33 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getMusicDirectory"
                    urlBuilder_.Append("rest/getMusicDirectory");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetMusicDirectoryResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetMusicFoldersResponse> GetMusicFoldersAsync()
        {
            return GetMusicFoldersAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetMusicFoldersResponse GetMusicFolders()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetMusicFoldersAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetMusicFoldersResponse> GetMusicFoldersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getMusicFolders"
                    urlBuilder_.Append("rest/getMusicFolders");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetMusicFoldersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetMusicFoldersResponse> PostGetMusicFoldersAsync(object body)
        {
            return PostGetMusicFoldersAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetMusicFoldersResponse PostGetMusicFolders(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetMusicFoldersAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all configured top-level music folders.
        /// </summary>
        /// <remarks>
        /// Returns all configured top-level music folders. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetMusicFoldersResponse> PostGetMusicFoldersAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getMusicFolders"
                    urlBuilder_.Append("rest/getMusicFolders");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetMusicFoldersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetNewestPodcastsResponse> GetNewestPodcastsAsync(int? count)
        {
            return GetNewestPodcastsAsync(count, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetNewestPodcastsResponse GetNewestPodcasts(int? count)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetNewestPodcastsAsync(count, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// </remarks>
        /// <param name="count">The maximum number of episodes to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetNewestPodcastsResponse> GetNewestPodcastsAsync(int? count, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getNewestPodcasts"
                    urlBuilder_.Append("rest/getNewestPodcasts");
                    urlBuilder_.Append('?');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetNewestPodcastsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetNewestPodcastsResponse> PostGetNewestPodcastsAsync(Body34 body)
        {
            return PostGetNewestPodcastsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetNewestPodcastsResponse PostGetNewestPodcasts(Body34 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetNewestPodcastsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the most recently published Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Returns the most recently published Podcast episodes.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetNewestPodcastsResponse> PostGetNewestPodcastsAsync(Body34 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getNewestPodcasts"
                    urlBuilder_.Append("rest/getNewestPodcasts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetNewestPodcastsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetNowPlayingResponse> GetNowPlayingAsync()
        {
            return GetNowPlayingAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetNowPlayingResponse GetNowPlaying()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetNowPlayingAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetNowPlayingResponse> GetNowPlayingAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getNowPlaying"
                    urlBuilder_.Append("rest/getNowPlaying");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetNowPlayingResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetNowPlayingResponse> PostGetNowPlayingAsync(object body)
        {
            return PostGetNowPlayingAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetNowPlayingResponse PostGetNowPlaying(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetNowPlayingAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns what is currently being played by all users.
        /// </summary>
        /// <remarks>
        /// Returns what is currently being played by all users. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetNowPlayingResponse> PostGetNowPlayingAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getNowPlaying"
                    urlBuilder_.Append("rest/getNowPlaying");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetNowPlayingResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> GetOpenSubsonicExtensionsAsync()
        {
            return GetOpenSubsonicExtensionsAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetOpenSubsonicExtensionsResponse GetOpenSubsonicExtensions()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetOpenSubsonicExtensionsAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> GetOpenSubsonicExtensionsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getOpenSubsonicExtensions"
                    urlBuilder_.Append("rest/getOpenSubsonicExtensions");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetOpenSubsonicExtensionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> PostGetOpenSubsonicExtensionsAsync(object body)
        {
            return PostGetOpenSubsonicExtensionsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetOpenSubsonicExtensionsResponse PostGetOpenSubsonicExtensions(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetOpenSubsonicExtensionsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List the OpenSubsonic extensions supported by this server.
        /// </summary>
        /// <remarks>
        /// List the OpenSubsonic extensions supported by this server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetOpenSubsonicExtensionsResponse> PostGetOpenSubsonicExtensionsAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getOpenSubsonicExtensions"
                    urlBuilder_.Append("rest/getOpenSubsonicExtensions");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetOpenSubsonicExtensionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlaylistResponse> GetPlaylistAsync(string id)
        {
            return GetPlaylistAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlaylistResponse GetPlaylist(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPlaylistAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// </remarks>
        /// <param name="id">ID of the playlist to return, as obtained by `getPlaylists`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlaylistResponse> GetPlaylistAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlaylist"
                    urlBuilder_.Append("rest/getPlaylist");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlaylistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlaylistResponse> PostGetPlaylistAsync(Body35 body)
        {
            return PostGetPlaylistAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlaylistResponse PostGetPlaylist(Body35 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPlaylistAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files in a saved playlist.
        /// </summary>
        /// <remarks>
        /// Returns a listing of files in a saved playlist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlaylistResponse> PostGetPlaylistAsync(Body35 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlaylist"
                    urlBuilder_.Append("rest/getPlaylist");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlaylistResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlaylistsResponse> GetPlaylistsAsync(string username)
        {
            return GetPlaylistsAsync(username, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlaylistsResponse GetPlaylists(string username)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPlaylistsAsync(username, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// </remarks>
        /// <param name="username">(Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlaylistsResponse> GetPlaylistsAsync(string username, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlaylists"
                    urlBuilder_.Append("rest/getPlaylists");
                    urlBuilder_.Append('?');
                    if (username != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlaylistsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlaylistsResponse> PostGetPlaylistsAsync(Body36 body)
        {
            return PostGetPlaylistsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlaylistsResponse PostGetPlaylists(Body36 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPlaylistsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all playlists a user is allowed to play.
        /// </summary>
        /// <remarks>
        /// Returns all playlists a user is allowed to play.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlaylistsResponse> PostGetPlaylistsAsync(Body36 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlaylists"
                    urlBuilder_.Append("rest/getPlaylists");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlaylistsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlayQueueResponse> GetPlayQueueAsync()
        {
            return GetPlayQueueAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlayQueueResponse GetPlayQueue()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPlayQueueAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlayQueueResponse> GetPlayQueueAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlayQueue"
                    urlBuilder_.Append("rest/getPlayQueue");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlayQueueResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlayQueueResponse> PostGetPlayQueueAsync(object body)
        {
            return PostGetPlayQueueAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlayQueueResponse PostGetPlayQueue(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPlayQueueAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlayQueueResponse> PostGetPlayQueueAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlayQueue"
                    urlBuilder_.Append("rest/getPlayQueue");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlayQueueResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> GetPlayQueueByIndexAsync()
        {
            return GetPlayQueueByIndexAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlayQueueByIndexResponse GetPlayQueueByIndex()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPlayQueueByIndexAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> GetPlayQueueByIndexAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlayQueueByIndex"
                    urlBuilder_.Append("rest/getPlayQueueByIndex");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlayQueueByIndexResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> PostGetPlayQueueByIndexAsync(object body)
        {
            return PostGetPlayQueueByIndexAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPlayQueueByIndexResponse PostGetPlayQueueByIndex(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPlayQueueByIndexAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Returns the state of the play queue for this user (as set by savePlayQueue). This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPlayQueueByIndexResponse> PostGetPlayQueueByIndexAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPlayQueueByIndex"
                    urlBuilder_.Append("rest/getPlayQueueByIndex");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPlayQueueByIndexResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPodcastEpisodeResponse> GetPodcastEpisodeAsync(string id)
        {
            return GetPodcastEpisodeAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPodcastEpisodeResponse GetPodcastEpisode(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPodcastEpisodeAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name getPodcastEpisode (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// </remarks>
        /// <param name="id">The podcast episode ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPodcastEpisodeResponse> GetPodcastEpisodeAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPodcastEpisode"
                    urlBuilder_.Append("rest/getPodcastEpisode");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPodcastEpisodeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPodcastEpisodeResponse> PostGetPodcastEpisodeAsync(Body37 body)
        {
            return PostGetPodcastEpisodeAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPodcastEpisodeResponse PostGetPodcastEpisode(Body37 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPodcastEpisodeAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a podcast episode.
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `getPodcastEpisode` (As returned by `getOpenSubsonicExtensions`). Returns details for a podcast episode.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPodcastEpisodeResponse> PostGetPodcastEpisodeAsync(Body37 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPodcastEpisode"
                    urlBuilder_.Append("rest/getPodcastEpisode");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPodcastEpisodeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPodcastsResponse> GetPodcastsAsync(string id, bool? includeEpisodes)
        {
            return GetPodcastsAsync(id, includeEpisodes, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPodcastsResponse GetPodcasts(string id, bool? includeEpisodes)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetPodcastsAsync(id, includeEpisodes, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// </remarks>
        /// <param name="id">(Since 1.9.0) If specified, only return the Podcast channel with this ID.</param>
        /// <param name="includeEpisodes">(Since 1.9.0) Whether to include Podcast episodes in the returned result.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPodcastsResponse> GetPodcastsAsync(string id, bool? includeEpisodes, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPodcasts"
                    urlBuilder_.Append("rest/getPodcasts");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (includeEpisodes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("includeEpisodes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeEpisodes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPodcastsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetPodcastsResponse> PostGetPodcastsAsync(Body38 body)
        {
            return PostGetPodcastsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetPodcastsResponse PostGetPodcasts(Body38 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetPodcastsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
        /// </summary>
        /// <remarks>
        /// Returns all Podcast channels the server subscribes to, and (optionally) their episodes. This method can also be used to return details for only one channel - refer to the id parameter. A typical use case for this method would be to first retrieve all channels without episodes, and then retrieve all episodes for the single channel the user selects.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetPodcastsResponse> PostGetPodcastsAsync(Body38 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getPodcasts"
                    urlBuilder_.Append("rest/getPodcasts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetPodcastsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetRandomSongsResponse> GetRandomSongsAsync(int? size, string genre, int? fromYear, int? toYear, string musicFolderId)
        {
            return GetRandomSongsAsync(size, genre, fromYear, toYear, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetRandomSongsResponse GetRandomSongs(int? size, string genre, int? fromYear, int? toYear, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetRandomSongsAsync(size, genre, fromYear, toYear, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// </remarks>
        /// <param name="size">The maximum number of songs to return. Max 500.</param>
        /// <param name="genre">Only returns songs belonging to this genre.</param>
        /// <param name="fromYear">(Since 1.9.0) Only return songs from this year or later.</param>
        /// <param name="toYear">Only return songs published before or in this year.</param>
        /// <param name="musicFolderId">Only return songs in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetRandomSongsResponse> GetRandomSongsAsync(int? size, string genre, int? fromYear, int? toYear, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getRandomSongs"
                    urlBuilder_.Append("rest/getRandomSongs");
                    urlBuilder_.Append('?');
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (genre != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("genre")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(genre, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (fromYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("fromYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(fromYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (toYear != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("toYear")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(toYear, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetRandomSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetRandomSongsResponse> PostGetRandomSongsAsync(Body39 body)
        {
            return PostGetRandomSongsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetRandomSongsResponse PostGetRandomSongs(Body39 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetRandomSongsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns random songs matching the given criteria.
        /// </summary>
        /// <remarks>
        /// Returns random songs matching the given criteria.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetRandomSongsResponse> PostGetRandomSongsAsync(Body39 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getRandomSongs"
                    urlBuilder_.Append("rest/getRandomSongs");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetRandomSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetScanStatusResponse> GetScanStatusAsync()
        {
            return GetScanStatusAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetScanStatusResponse GetScanStatus()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetScanStatusAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetScanStatusResponse> GetScanStatusAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getScanStatus"
                    urlBuilder_.Append("rest/getScanStatus");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetScanStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetScanStatusResponse> PostGetScanStatusAsync(object body)
        {
            return PostGetScanStatusAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetScanStatusResponse PostGetScanStatus(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetScanStatusAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the current status for media library scanning.
        /// </summary>
        /// <remarks>
        /// Returns the current status for media library scanning. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetScanStatusResponse> PostGetScanStatusAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getScanStatus"
                    urlBuilder_.Append("rest/getScanStatus");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetScanStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSharesResponse> GetSharesAsync()
        {
            return GetSharesAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSharesResponse GetShares()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetSharesAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSharesResponse> GetSharesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getShares"
                    urlBuilder_.Append("rest/getShares");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSharesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSharesResponse> PostGetSharesAsync(object body)
        {
            return PostGetSharesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSharesResponse PostGetShares(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetSharesAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about shared media this user is allowed to manage.
        /// </summary>
        /// <remarks>
        /// Returns information about shared media this user is allowed to manage. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSharesResponse> PostGetSharesAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getShares"
                    urlBuilder_.Append("rest/getShares");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSharesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSimilarSongsResponse> GetSimilarSongsAsync(string id, int? count)
        {
            return GetSimilarSongsAsync(id, count, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSimilarSongsResponse GetSimilarSongs(string id, int? count)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetSimilarSongsAsync(id, count, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSimilarSongsResponse> GetSimilarSongsAsync(string id, int? count, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSimilarSongs"
                    urlBuilder_.Append("rest/getSimilarSongs");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSimilarSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSimilarSongsResponse> PostGetSimilarSongsAsync(Body40 body)
        {
            return PostGetSimilarSongsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSimilarSongsResponse PostGetSimilarSongs(Body40 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetSimilarSongsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists.
        /// </summary>
        /// <remarks>
        /// Returns a random collection of songs from the given artist and similar artists, using data from last.fm. Typically used for artist radio features.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSimilarSongsResponse> PostGetSimilarSongsAsync(Body40 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSimilarSongs"
                    urlBuilder_.Append("rest/getSimilarSongs");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSimilarSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSimilarSongs2Response> GetSimilarSongs2Async(string id, int? count)
        {
            return GetSimilarSongs2Async(id, count, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSimilarSongs2Response GetSimilarSongs2(string id, int? count)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetSimilarSongs2Async(id, count, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="id">The artist, album or song ID.</param>
        /// <param name="count">Max number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSimilarSongs2Response> GetSimilarSongs2Async(string id, int? count, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSimilarSongs2"
                    urlBuilder_.Append("rest/getSimilarSongs2");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSimilarSongs2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSimilarSongs2Response> PostGetSimilarSongs2Async(Body41 body)
        {
            return PostGetSimilarSongs2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSimilarSongs2Response PostGetSimilarSongs2(Body41 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetSimilarSongs2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a random collection of songs from the given artist and similar artists (v2).
        /// </summary>
        /// <remarks>
        /// Similar to `getSimilarSongs`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSimilarSongs2Response> PostGetSimilarSongs2Async(Body41 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSimilarSongs2"
                    urlBuilder_.Append("rest/getSimilarSongs2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSimilarSongs2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSongResponse> GetSongAsync(string id)
        {
            return GetSongAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSongResponse GetSong(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetSongAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// </remarks>
        /// <param name="id">The song ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSongResponse> GetSongAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSong"
                    urlBuilder_.Append("rest/getSong");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSongResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSongResponse> PostGetSongAsync(Body42 body)
        {
            return PostGetSongAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSongResponse PostGetSong(Body42 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetSongAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a song.
        /// </summary>
        /// <remarks>
        /// Returns details for a song.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSongResponse> PostGetSongAsync(Body42 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSong"
                    urlBuilder_.Append("rest/getSong");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSongResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSongsByGenreResponse> GetSongsByGenreAsync(string genre, int? count, int? offset, string musicFolderId)
        {
            return GetSongsByGenreAsync(genre, count, offset, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSongsByGenreResponse GetSongsByGenre(string genre, int? count, int? offset, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetSongsByGenreAsync(genre, count, offset, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// </remarks>
        /// <param name="genre">The genre, as returned by `getGenres`.</param>
        /// <param name="count">The maximum number of songs to return. Max 500.</param>
        /// <param name="offset">The offset. Useful if you want to page through the songs in a genre.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSongsByGenreResponse> GetSongsByGenreAsync(string genre, int? count, int? offset, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (genre == null)
                throw new System.ArgumentNullException("genre");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSongsByGenre"
                    urlBuilder_.Append("rest/getSongsByGenre");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("genre")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(genre, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSongsByGenreResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetSongsByGenreResponse> PostGetSongsByGenreAsync(Body43 body)
        {
            return PostGetSongsByGenreAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetSongsByGenreResponse PostGetSongsByGenre(Body43 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetSongsByGenreAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns songs in a given genre.
        /// </summary>
        /// <remarks>
        /// Returns songs in a given genre.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetSongsByGenreResponse> PostGetSongsByGenreAsync(Body43 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getSongsByGenre"
                    urlBuilder_.Append("rest/getSongsByGenre");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetSongsByGenreResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetStarredResponse> GetStarredAsync(string musicFolderId)
        {
            return GetStarredAsync(musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetStarredResponse GetStarred(string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetStarredAsync(musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetStarredResponse> GetStarredAsync(string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getStarred"
                    urlBuilder_.Append("rest/getStarred");
                    urlBuilder_.Append('?');
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetStarredResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetStarredResponse> PostGetStarredAsync(object body)
        {
            return PostGetStarredAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetStarredResponse PostGetStarred(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetStarredAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Returns starred songs, albums and artists.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetStarredResponse> PostGetStarredAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getStarred"
                    urlBuilder_.Append("rest/getStarred");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetStarredResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetStarred2Response> GetStarred2Async(string musicFolderId)
        {
            return GetStarred2Async(musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetStarred2Response GetStarred2(string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetStarred2Async(musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// </remarks>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetStarred2Response> GetStarred2Async(string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getStarred2"
                    urlBuilder_.Append("rest/getStarred2");
                    urlBuilder_.Append('?');
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetStarred2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetStarred2Response> PostGetStarred2Async(object body)
        {
            return PostGetStarred2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetStarred2Response PostGetStarred2(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetStarred2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns starred songs, albums and artists.
        /// </summary>
        /// <remarks>
        /// Similar to `getStarred`, but organizes music according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetStarred2Response> PostGetStarred2Async(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getStarred2"
                    urlBuilder_.Append("rest/getStarred2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetStarred2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetTopSongsResponse> GetTopSongsAsync(string id, int? count)
        {
            return GetTopSongsAsync(id, count, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetTopSongsResponse GetTopSongs(string id, int? count)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetTopSongsAsync(id, count, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// </remarks>
        /// <param name="id">The artist name.</param>
        /// <param name="count">The maximum number of songs to return.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetTopSongsResponse> GetTopSongsAsync(string id, int? count, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getTopSongs"
                    urlBuilder_.Append("rest/getTopSongs");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetTopSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetTopSongsResponse> PostGetTopSongsAsync(Body44 body)
        {
            return PostGetTopSongsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetTopSongsResponse PostGetTopSongs(Body44 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetTopSongsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns top songs for the given artist.
        /// </summary>
        /// <remarks>
        /// Returns top songs for the given artist, using data from last.fm.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetTopSongsResponse> PostGetTopSongsAsync(Body44 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getTopSongs"
                    urlBuilder_.Append("rest/getTopSongs");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetTopSongsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetUserResponse> GetUserAsync(string username)
        {
            return GetUserAsync(username, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetUserResponse GetUser(string username)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetUserAsync(username, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// </remarks>
        /// <param name="username">The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetUserResponse> GetUserAsync(string username, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getUser"
                    urlBuilder_.Append("rest/getUser");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetUserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetUserResponse> PostGetUserAsync(Body45 body)
        {
            return PostGetUserAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetUserResponse PostGetUser(Body45 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetUserAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about a given user, including which authorization roles and folder access it has.
        /// </summary>
        /// <remarks>
        /// Get details about a given user, including which authorization roles and folder access it has. Can be used to enable/disable certain features in the client, such as jukebox control.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetUserResponse> PostGetUserAsync(Body45 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getUser"
                    urlBuilder_.Append("rest/getUser");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetUserResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetUsersResponse> GetUsersAsync()
        {
            return GetUsersAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetUsersResponse GetUsers()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetUsersAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetUsersResponse> GetUsersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getUsers"
                    urlBuilder_.Append("rest/getUsers");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetUsersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetUsersResponse> PostGetUsersAsync(object body)
        {
            return PostGetUsersAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetUsersResponse PostGetUsers(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetUsersAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get details about all users, including which authorization roles and folder access they have
        /// </summary>
        /// <remarks>
        /// Get details about all users, including which authorization roles and folder access they have. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetUsersResponse> PostGetUsersAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getUsers"
                    urlBuilder_.Append("rest/getUsers");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetUsersResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetVideoInfoResponse> GetVideoInfoAsync(string id)
        {
            return GetVideoInfoAsync(id, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetVideoInfoResponse GetVideoInfo(string id)
        {
            return System.Threading.Tasks.Task.Run(async () => await GetVideoInfoAsync(id, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// </remarks>
        /// <param name="id">The video ID.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetVideoInfoResponse> GetVideoInfoAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getVideoInfo"
                    urlBuilder_.Append("rest/getVideoInfo");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetVideoInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetVideoInfoResponse> PostGetVideoInfoAsync(Body46 body)
        {
            return PostGetVideoInfoAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetVideoInfoResponse PostGetVideoInfo(Body46 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetVideoInfoAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns details for a video.
        /// </summary>
        /// <remarks>
        /// Returns details for a video, including information about available audio tracks, subtitles (captions) and conversions.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetVideoInfoResponse> PostGetVideoInfoAsync(Body46 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getVideoInfo"
                    urlBuilder_.Append("rest/getVideoInfo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetVideoInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetVideosResponse> GetVideosAsync()
        {
            return GetVideosAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetVideosResponse GetVideos()
        {
            return System.Threading.Tasks.Task.Run(async () => await GetVideosAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetVideosResponse> GetVideosAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getVideos"
                    urlBuilder_.Append("rest/getVideos");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetVideosResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetVideosResponse> PostGetVideosAsync(object body)
        {
            return PostGetVideosAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetVideosResponse PostGetVideos(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostGetVideosAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all video files.
        /// </summary>
        /// <remarks>
        /// Returns all video files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetVideosResponse> PostGetVideosAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/getVideos"
                    urlBuilder_.Append("rest/getVideos");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetVideosResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> Hls_m3u8Async(string id, int? bitRate, string audioTrack)
        {
            return Hls_m3u8Async(id, bitRate, audioTrack, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual string Hls_m3u8(string id, int? bitRate, string audioTrack)
        {
            return System.Threading.Tasks.Task.Run(async () => await Hls_m3u8Async(id, bitRate, audioTrack, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the media file to stream.</param>
        /// <param name="bitRate">If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360</param>
        /// <param name="audioTrack">The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> Hls_m3u8Async(string id, int? bitRate, string audioTrack, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.apple.mpegurl"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/hls.m3u8"
                    urlBuilder_.Append("rest/hls.m3u8");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (bitRate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("bitRate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bitRate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (audioTrack != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("audioTrack")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(audioTrack, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> PostHls_m3u8Async(Body47 body)
        {
            return PostHls_m3u8Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual string PostHls_m3u8(Body47 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostHls_m3u8Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Downloads a given media file (HLS).
        /// </summary>
        /// <remarks>
        /// Creates an HLS (HTTP Live Streaming) playlist used for streaming video or audio. HLS is a streaming protocol implemented by Apple and works by breaking the overall stream into a sequence of small HTTP-based file downloads. It’s supported by iOS and newer versions of Android. This method also supports adaptive bitrate streaming, see the bitRate parameter.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> PostHls_m3u8Async(Body47 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.apple.mpegurl"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/hls.m3u8"
                    urlBuilder_.Append("rest/hls.m3u8");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<JukeboxControlResponse> JukeboxControlAsync(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain)
        {
            return JukeboxControlAsync(action, index, offset, id, gain, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual JukeboxControlResponse JukeboxControl(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain)
        {
            return System.Threading.Tasks.Task.Run(async () => await JukeboxControlAsync(action, index, offset, id, gain, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// </remarks>
        /// <param name="action">The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain</param>
        /// <param name="index">Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.</param>
        /// <param name="offset">(Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.</param>
        /// <param name="id">Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)</param>
        /// <param name="gain">Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<JukeboxControlResponse> JukeboxControlAsync(JukeboxAction action, int? index, int? offset, System.Collections.Generic.IEnumerable<string> id, float? gain, System.Threading.CancellationToken cancellationToken)
        {
            if (action == null)
                throw new System.ArgumentNullException("action");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/jukeboxControl"
                    urlBuilder_.Append("rest/jukeboxControl");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("action")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(action, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (index != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("index")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(index, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (id != null)
                    {
                            foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (gain != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("gain")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(gain, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JukeboxControlResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<JukeboxControlResponse> PostJukeboxControlAsync(Body48 body)
        {
            return PostJukeboxControlAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual JukeboxControlResponse PostJukeboxControl(Body48 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostJukeboxControlAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
        /// </summary>
        /// <remarks>
        /// Controls the jukebox, i.e., playback directly on the server’s audio hardware. Note: The user must be authorized to control the jukebox (see Settings &gt; Users &gt; User is allowed to play files in jukebox mode).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<JukeboxControlResponse> PostJukeboxControlAsync(Body48 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/jukeboxControl"
                    urlBuilder_.Append("rest/jukeboxControl");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<JukeboxControlResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PingAsync()
        {
            return PingAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse Ping()
        {
            return System.Threading.Tasks.Task.Run(async () => await PingAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PingAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/ping"
                    urlBuilder_.Append("rest/ping");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostPingAsync(object body)
        {
            return PostPingAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostPing(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostPingAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Used to test connectivity with the server.
        /// </summary>
        /// <remarks>
        /// Test connectivity with the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostPingAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/ping"
                    urlBuilder_.Append("rest/ping");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> RefreshPodcastsAsync()
        {
            return RefreshPodcastsAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse RefreshPodcasts()
        {
            return System.Threading.Tasks.Task.Run(async () => await RefreshPodcastsAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> RefreshPodcastsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/refreshPodcasts"
                    urlBuilder_.Append("rest/refreshPodcasts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostRefreshPodcastsAsync(object body)
        {
            return PostRefreshPodcastsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostRefreshPodcasts(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostRefreshPodcastsAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Requests the server to check for new Podcast episodes.
        /// </summary>
        /// <remarks>
        /// Requests the server to check for new Podcast episodes. Note: The user must be authorized for Podcast administration (see Settings &gt; Users &gt; User is allowed to administrate Podcasts).
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostRefreshPodcastsAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/refreshPodcasts"
                    urlBuilder_.Append("rest/refreshPodcasts");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueAsync(string id, string current, int? position)
        {
            return SavePlayQueueAsync(id, current, position, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse SavePlayQueue(string id, string current, int? position)
        {
            return System.Threading.Tasks.Task.Run(async () => await SavePlayQueueAsync(id, current, position, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="current">The ID of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueAsync(string id, string current, int? position, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/savePlayQueue"
                    urlBuilder_.Append("rest/savePlayQueue");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (current != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("current")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(current, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (position != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("position")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(position, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueAsync(Body49 body)
        {
            return PostSavePlayQueueAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostSavePlayQueue(Body49 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSavePlayQueueAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueAsync(Body49 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/savePlayQueue"
                    urlBuilder_.Append("rest/savePlayQueue");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueByIndexAsync(string id, int? currentIndex, int? position)
        {
            return SavePlayQueueByIndexAsync(id, currentIndex, position, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse SavePlayQueueByIndex(string id, int? currentIndex, int? position)
        {
            return System.Threading.Tasks.Task.Run(async () => await SavePlayQueueByIndexAsync(id, currentIndex, position, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user, using queue index.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// </remarks>
        /// <param name="id">ID of a song in the play queue. Use one id parameter for each song in the play queue.</param>
        /// <param name="currentIndex">The index of the current playing song.</param>
        /// <param name="position">The position in milliseconds within the currently playing song.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> SavePlayQueueByIndexAsync(string id, int? currentIndex, int? position, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/savePlayQueueByIndex"
                    urlBuilder_.Append("rest/savePlayQueueByIndex");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (currentIndex != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("currentIndex")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(currentIndex, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (position != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("position")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(position, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueByIndexAsync(Body50 body)
        {
            return PostSavePlayQueueByIndexAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostSavePlayQueueByIndex(Body50 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSavePlayQueueByIndexAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Saves the state of the play queue for this user.
        /// </summary>
        /// <remarks>
        /// Saves the state of the play queue for this user. This includes the tracks in the play queue, the currently playing track, and the position within this track. Typically used to allow a user to move between different clients/apps while retaining the same play queue (for instance when listening to an audio book). `id` is optional. Send a call without any parameters to clear the currently saved queue.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostSavePlayQueueByIndexAsync(Body50 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/savePlayQueueByIndex"
                    urlBuilder_.Append("rest/savePlayQueueByIndex");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> ScrobbleAsync(string id, int? time, bool? submission)
        {
            return ScrobbleAsync(id, time, submission, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse Scrobble(string id, int? time, bool? submission)
        {
            return System.Threading.Tasks.Task.Run(async () => await ScrobbleAsync(id, time, submission, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to scrobble.</param>
        /// <param name="time">(Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.</param>
        /// <param name="submission">Whether this is a “submission” or a “now playing” notification.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> ScrobbleAsync(string id, int? time, bool? submission, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/scrobble"
                    urlBuilder_.Append("rest/scrobble");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (time != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("time")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(time, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (submission != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("submission")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(submission, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostScrobbleAsync(Body51 body)
        {
            return PostScrobbleAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostScrobble(Body51 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostScrobbleAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Registers the local playback of one or more media files.
        /// </summary>
        /// <remarks>
        /// Registers the local playback of one or more media files. Typically used when playing media that is cached on the client. This operation includes the following:
        /// <br/>
        /// <br/>* “Scrobbles” the media files on last.fm if the user has configured his/her last.fm credentials on the server.
        /// <br/>* Updates the play count and last played timestamp for the media files. (Since 1.11.0)
        /// <br/>* Makes the media files appear in the “Now playing” page in the web app, and appear in the list of songs returned by getNowPlaying (Since 1.11.0)
        /// <br/>
        /// <br/>Since 1.8.0 you may specify multiple id (and optionally time) parameters to scrobble multiple files.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostScrobbleAsync(Body51 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/scrobble"
                    urlBuilder_.Append("rest/scrobble");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual System.Threading.Tasks.Task<SearchResponse> SearchAsync(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan)
        {
            return SearchAsync(artist, album, title, any, count, offset, newerThan, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual SearchResponse Search(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan)
        {
            return System.Threading.Tasks.Task.Run(async () => await SearchAsync(artist, album, title, any, count, offset, newerThan, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="artist">Artist to search for.</param>
        /// <param name="album">Album to search for.</param>
        /// <param name="title">Song title to search for.</param>
        /// <param name="any">Searches all fields.</param>
        /// <param name="count">Maximum number of results to return.</param>
        /// <param name="offset">Search result offset. Used for paging.</param>
        /// <param name="newerThan">Only return matches that are newer than this. Given as milliseconds since 1970.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual async System.Threading.Tasks.Task<SearchResponse> SearchAsync(string artist, string album, string title, bool? any, int? count, int? offset, int? newerThan, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search"
                    urlBuilder_.Append("rest/search");
                    urlBuilder_.Append('?');
                    if (artist != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artist")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artist, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (album != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("album")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(album, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (any != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("any")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(any, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (count != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("count")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(count, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (offset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("offset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (newerThan != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("newerThan")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(newerThan, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual System.Threading.Tasks.Task<SearchResponse> PostSearchAsync(Body52 body)
        {
            return PostSearchAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual SearchResponse PostSearch(Body52 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSearchAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// </summary>
        /// <remarks>
        /// Deprecated since 1.4.0, use search2 instead.
        /// <br/>
        /// <br/>Returns a listing of files matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual async System.Threading.Tasks.Task<SearchResponse> PostSearchAsync(Body52 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search"
                    urlBuilder_.Append("rest/search");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Search2Response> Search2Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId)
        {
            return Search2Async(query, artistCount, artistOffset, albumCount, albumOffset, songCount, songOffset, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual Search2Response Search2(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await Search2Async(query, artistCount, artistOffset, albumCount, albumOffset, songCount, songOffset, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// </remarks>
        /// <param name="query">Search query.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Search2Response> Search2Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (query == null)
                throw new System.ArgumentNullException("query");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search2"
                    urlBuilder_.Append("rest/search2");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("query")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(query, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (artistCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artistCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artistCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (artistOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artistOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artistOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (albumCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("albumCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(albumCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (albumOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("albumOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(albumOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("songCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(songCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("songOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(songOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Search2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Search2Response> PostSearch2Async(Body53 body)
        {
            return PostSearch2Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual Search2Response PostSearch2(Body53 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSearch2Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Search2Response> PostSearch2Async(Body53 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search2"
                    urlBuilder_.Append("rest/search2");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Search2Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Search3Response> Search3Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId)
        {
            return Search3Async(query, artistCount, artistOffset, albumCount, albumOffset, songCount, songOffset, musicFolderId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual Search3Response Search3(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId)
        {
            return System.Threading.Tasks.Task.Run(async () => await Search3Async(query, artistCount, artistOffset, albumCount, albumOffset, songCount, songOffset, musicFolderId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// </remarks>
        /// <param name="query">Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.</param>
        /// <param name="artistCount">Maximum number of artists to return.</param>
        /// <param name="artistOffset">Search result offset for artists. Used for paging.</param>
        /// <param name="albumCount">Maximum number of albums to return.</param>
        /// <param name="albumOffset">Search result offset for albums. Used for paging.</param>
        /// <param name="songCount">Maximum number of songs to return.</param>
        /// <param name="songOffset">Search result offset for songs. Used for paging.</param>
        /// <param name="musicFolderId">(Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Search3Response> Search3Async(string query, int? artistCount, int? artistOffset, int? albumCount, int? albumOffset, int? songCount, int? songOffset, string musicFolderId, System.Threading.CancellationToken cancellationToken)
        {
            if (query == null)
                throw new System.ArgumentNullException("query");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search3"
                    urlBuilder_.Append("rest/search3");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("query")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(query, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (artistCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artistCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artistCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (artistOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("artistOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(artistOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (albumCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("albumCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(albumCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (albumOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("albumOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(albumOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songCount != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("songCount")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(songCount, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("songOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(songOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(musicFolderId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Search3Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Search3Response> PostSearch3Async(Body54 body)
        {
            return PostSearch3Async(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual Search3Response PostSearch3(Body54 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSearch3Async(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
        /// </summary>
        /// <remarks>
        /// Returns albums, artists and songs matching the given search criteria. Supports paging through the result.
        /// <br/>
        /// <br/>Music is organized according to ID3 tags.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Search3Response> PostSearch3Async(Body54 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/search3"
                    urlBuilder_.Append("rest/search3");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Search3Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> SetRatingAsync(string id, int rating)
        {
            return SetRatingAsync(id, rating, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse SetRating(string id, int rating)
        {
            return System.Threading.Tasks.Task.Run(async () => await SetRatingAsync(id, rating, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file (song) or folder (album/artist) to rate.</param>
        /// <param name="rating">The rating between 1 and 5 (inclusive), or 0 to remove the rating.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> SetRatingAsync(string id, int rating, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (rating == null)
                throw new System.ArgumentNullException("rating");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/setRating"
                    urlBuilder_.Append("rest/setRating");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("rating")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rating, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostSetRatingAsync(Body55 body)
        {
            return PostSetRatingAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostSetRating(Body55 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostSetRatingAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sets the rating for a music file.
        /// </summary>
        /// <remarks>
        /// Sets the rating for a music file.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostSetRatingAsync(Body55 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/setRating"
                    urlBuilder_.Append("rest/setRating");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> StarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId)
        {
            return StarAsync(id, albumId, artistId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse Star(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId)
        {
            return System.Threading.Tasks.Task.Run(async () => await StarAsync(id, albumId, artistId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> StarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/star"
                    urlBuilder_.Append("rest/star");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                            foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (albumId != null)
                    {
                            foreach (var item_ in albumId) { urlBuilder_.Append(System.Uri.EscapeDataString("albumId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (artistId != null)
                    {
                            foreach (var item_ in artistId) { urlBuilder_.Append(System.Uri.EscapeDataString("artistId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostStarAsync(Body56 body)
        {
            return PostStarAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostStar(Body56 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostStarAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attaches a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Attaches a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostStarAsync(Body56 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/star"
                    urlBuilder_.Append("rest/star");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<StartScanResponse> StartScanAsync()
        {
            return StartScanAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual StartScanResponse StartScan()
        {
            return System.Threading.Tasks.Task.Run(async () => await StartScanAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StartScanResponse> StartScanAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/startScan"
                    urlBuilder_.Append("rest/startScan");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StartScanResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<StartScanResponse> PostStartScanAsync(object body)
        {
            return PostStartScanAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual StartScanResponse PostStartScan(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostStartScanAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiates a rescan of the media libraries.
        /// </summary>
        /// <remarks>
        /// Initiates a rescan of the media libraries. Takes no extra parameters.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StartScanResponse> PostStartScanAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/startScan"
                    urlBuilder_.Append("rest/startScan");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StartScanResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> StreamAsync(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted)
        {
            return StreamAsync(id, maxBitRate, format, timeOffset, size, estimateContentLength, converted, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse Stream(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted)
        {
            return System.Threading.Tasks.Task.Run(async () => await StreamAsync(id, maxBitRate, format, timeOffset, size, estimateContentLength, converted, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server support the Transcode Offet extension, then it must accept the timeOffset parameter for music too.
        /// </remarks>
        /// <param name="id">A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.</param>
        /// <param name="maxBitRate">(Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.</param>
        /// <param name="format">(Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.</param>
        /// <param name="timeOffset">By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.</param>
        /// <param name="size">(Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.</param>
        /// <param name="estimateContentLength">(Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.</param>
        /// <param name="converted">(Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.</param>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> StreamAsync(string id, int? maxBitRate, string format, int? timeOffset, string size, bool? estimateContentLength, bool? converted, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/stream"
                    urlBuilder_.Append("rest/stream");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (maxBitRate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("maxBitRate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(maxBitRate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (timeOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("timeOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(timeOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (estimateContentLength != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("estimateContentLength")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(estimateContentLength, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (converted != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("converted")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(converted, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> PostStreamAsync(Body57 body)
        {
            return PostStreamAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual FileResponse PostStream(Body57 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostStreamAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Streams a given media file.
        /// </summary>
        /// <remarks>
        /// Streams a given media file.
        /// <br/>
        /// <br/>OpenSubsonic servers must not count access to this endpoint as a play and increase playcount. Clients can use the Scrobble endpoint to indicate that a media is played ensuring proper data in all cases.
        /// <br/>
        /// <br/>If the server supports the Transcode Offset extension, then it must accept the timeOffset parameter for music too.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Success (binary) or error (xml) response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> PostStreamAsync(Body57 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/binary"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/stream"
                    urlBuilder_.Append("rest/stream");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetTokenInfoResponse> TokenInfoAsync()
        {
            return TokenInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetTokenInfoResponse TokenInfo()
        {
            return System.Threading.Tasks.Task.Run(async () => await TokenInfoAsync(System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetTokenInfoResponse> TokenInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/tokenInfo"
                    urlBuilder_.Append("rest/tokenInfo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetTokenInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetTokenInfoResponse> PostTokenInfoAsync(object body)
        {
            return PostTokenInfoAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual GetTokenInfoResponse PostTokenInfo(object body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostTokenInfoAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns information about an API key
        /// </summary>
        /// <remarks>
        /// OpenSubsonic extension name `apiKeyAuthentication` (As returned by `getOpenSubsonicExtensions`). Returns data about an API key.
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetTokenInfoResponse> PostTokenInfoAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/tokenInfo"
                    urlBuilder_.Append("rest/tokenInfo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetTokenInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> UnstarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId)
        {
            return UnstarAsync(id, albumId, artistId, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse Unstar(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId)
        {
            return System.Threading.Tasks.Task.Run(async () => await UnstarAsync(id, albumId, artistId, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// </remarks>
        /// <param name="id">The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.</param>
        /// <param name="albumId">The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <param name="artistId">The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> UnstarAsync(System.Collections.Generic.IEnumerable<string> id, System.Collections.Generic.IEnumerable<string> albumId, System.Collections.Generic.IEnumerable<string> artistId, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/unstar"
                    urlBuilder_.Append("rest/unstar");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                            foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (albumId != null)
                    {
                            foreach (var item_ in albumId) { urlBuilder_.Append(System.Uri.EscapeDataString("albumId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (artistId != null)
                    {
                            foreach (var item_ in artistId) { urlBuilder_.Append(System.Uri.EscapeDataString("artistId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostUnstarAsync(Body58 body)
        {
            return PostUnstarAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostUnstar(Body58 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostUnstarAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes a star to a song, album or artist.
        /// </summary>
        /// <remarks>
        /// Removes a star to a song, album or artist.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostUnstarAsync(Body58 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/unstar"
                    urlBuilder_.Append("rest/unstar");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> UpdateInternetRadioStationAsync(string id, string streamUrl, string name, string homepageUrl)
        {
            return UpdateInternetRadioStationAsync(id, streamUrl, name, homepageUrl, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse UpdateInternetRadioStation(string id, string streamUrl, string name, string homepageUrl)
        {
            return System.Threading.Tasks.Task.Run(async () => await UpdateInternetRadioStationAsync(id, streamUrl, name, homepageUrl, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// </remarks>
        /// <param name="id">The ID of the station.</param>
        /// <param name="streamUrl">The stream URL for the station.</param>
        /// <param name="name">The user-defined name for the station.</param>
        /// <param name="homepageUrl">The home page URL for the station.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> UpdateInternetRadioStationAsync(string id, string streamUrl, string name, string homepageUrl, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (streamUrl == null)
                throw new System.ArgumentNullException("streamUrl");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateInternetRadioStation"
                    urlBuilder_.Append("rest/updateInternetRadioStation");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("streamUrl")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(streamUrl, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (homepageUrl != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("homepageUrl")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(homepageUrl, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostUpdateInternetRadioStationAsync(Body59 body)
        {
            return PostUpdateInternetRadioStationAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostUpdateInternetRadioStation(Body59 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostUpdateInternetRadioStationAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an existing internet radio station.
        /// </summary>
        /// <remarks>
        /// Updates an existing internet radio station. Only users with admin privileges are allowed to call this method.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostUpdateInternetRadioStationAsync(Body59 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateInternetRadioStation"
                    urlBuilder_.Append("rest/updateInternetRadioStation");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> UpdatePlaylistAsync(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove)
        {
            return UpdatePlaylistAsync(playlistId, name, comment, @public, songIdToAdd, songIndexToRemove, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse UpdatePlaylist(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove)
        {
            return System.Threading.Tasks.Task.Run(async () => await UpdatePlaylistAsync(playlistId, name, comment, @public, songIdToAdd, songIndexToRemove, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </remarks>
        /// <param name="playlistId">The playlist ID.</param>
        /// <param name="name">The human-readable name of the playlist.</param>
        /// <param name="comment">The playlist comment.</param>
        /// <param name="public">`true` if the playlist should be visible to all users, `false` otherwise.</param>
        /// <param name="songIdToAdd">Add this song with this ID to the playlist. Multiple parameters allowed.</param>
        /// <param name="songIndexToRemove">Remove the song at this position in the playlist. Multiple parameters allowed.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> UpdatePlaylistAsync(string playlistId, string name, string comment, bool? @public, System.Collections.Generic.IEnumerable<string> songIdToAdd, System.Collections.Generic.IEnumerable<int> songIndexToRemove, System.Threading.CancellationToken cancellationToken)
        {
            if (playlistId == null)
                throw new System.ArgumentNullException("playlistId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updatePlaylist"
                    urlBuilder_.Append("rest/updatePlaylist");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("playlistId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(playlistId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (comment != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("comment")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(comment, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (@public != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("public")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(@public, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (songIdToAdd != null)
                    {
                            foreach (var item_ in songIdToAdd) { urlBuilder_.Append(System.Uri.EscapeDataString("songIdToAdd")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (songIndexToRemove != null)
                    {
                            foreach (var item_ in songIndexToRemove) { urlBuilder_.Append(System.Uri.EscapeDataString("songIndexToRemove")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostUpdatePlaylistAsync(Body60 body)
        {
            return PostUpdatePlaylistAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostUpdatePlaylist(Body60 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostUpdatePlaylistAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// </summary>
        /// <remarks>
        /// Updates a playlist. Only the owner of a playlist is allowed to update it.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostUpdatePlaylistAsync(Body60 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updatePlaylist"
                    urlBuilder_.Append("rest/updatePlaylist");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> UpdateShareAsync(string id, string description, int? expires)
        {
            return UpdateShareAsync(id, description, expires, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse UpdateShare(string id, string description, int? expires)
        {
            return System.Threading.Tasks.Task.Run(async () => await UpdateShareAsync(id, description, expires, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// </remarks>
        /// <param name="id">ID of the share to update.</param>
        /// <param name="description">A user-defined description that will be displayed to people visiting the shared media.</param>
        /// <param name="expires">The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> UpdateShareAsync(string id, string description, int? expires, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateShare"
                    urlBuilder_.Append("rest/updateShare");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (description != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("description")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(description, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (expires != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("expires")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(expires, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostUpdateShareAsync(Body61 body)
        {
            return PostUpdateShareAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostUpdateShare(Body61 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostUpdateShareAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the description and/or expiration date for an existing share.
        /// </summary>
        /// <remarks>
        /// Updates the description and/or expiration date for an existing share.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostUpdateShareAsync(Body61 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateShare"
                    urlBuilder_.Append("rest/updateShare");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> UpdateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate)
        {
            return UpdateUserAsync(username, password, email, ldapAuthenticated, adminRole, settingsRole, streamRole, jukeboxRole, downloadRole, uploadRole, coverArtRole, commentRole, podcastRole, shareRole, videoConversionRole, musicFolderId, maxBitRate, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse UpdateUser(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate)
        {
            return System.Threading.Tasks.Task.Run(async () => await UpdateUserAsync(username, password, email, ldapAuthenticated, adminRole, settingsRole, streamRole, jukeboxRole, downloadRole, uploadRole, coverArtRole, commentRole, podcastRole, shareRole, videoConversionRole, musicFolderId, maxBitRate, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// </remarks>
        /// <param name="username">The name of the user.</param>
        /// <param name="password">The password of the user, either in clear text of hex-encoded (see above).</param>
        /// <param name="email">The email address of the user.</param>
        /// <param name="ldapAuthenticated">Whether the user is authenicated in LDAP.</param>
        /// <param name="adminRole">Whether the user is administrator.</param>
        /// <param name="settingsRole">Whether the user is allowed to change personal settings and password.</param>
        /// <param name="streamRole">Whether the user is allowed to play files.</param>
        /// <param name="jukeboxRole">Whether the user is allowed to play files in jukebox mode.</param>
        /// <param name="downloadRole">Whether the user is allowed to download files.</param>
        /// <param name="uploadRole">Whether the user is allowed to upload files.</param>
        /// <param name="coverArtRole">Whether the user is allowed to change cover art and tags.</param>
        /// <param name="commentRole">Whether the user is allowed to create and edit comments and ratings.</param>
        /// <param name="podcastRole">Whether the user is allowed to administrate Podcasts.</param>
        /// <param name="shareRole">Whether the user is allowed to share files with anyone.</param>
        /// <param name="videoConversionRole">(Since 1.15.0) Whether the user is allowed to start video conversions.</param>
        /// <param name="musicFolderId">(Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.</param>
        /// <param name="maxBitRate">(Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.</param>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> UpdateUserAsync(string username, string password, string email, bool? ldapAuthenticated, bool? adminRole, bool? settingsRole, bool? streamRole, bool? jukeboxRole, bool? downloadRole, bool? uploadRole, bool? coverArtRole, bool? commentRole, bool? podcastRole, bool? shareRole, bool? videoConversionRole, System.Collections.Generic.IEnumerable<string> musicFolderId, MaxBitRate? maxBitRate, System.Threading.CancellationToken cancellationToken)
        {
            if (username == null)
                throw new System.ArgumentNullException("username");

            if (password == null)
                throw new System.ArgumentNullException("password");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateUser"
                    urlBuilder_.Append("rest/updateUser");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("username")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("password")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(password, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (email != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("email")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(email, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (ldapAuthenticated != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ldapAuthenticated")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(ldapAuthenticated, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (adminRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("adminRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(adminRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (settingsRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("settingsRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(settingsRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (streamRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("streamRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(streamRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (jukeboxRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("jukeboxRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(jukeboxRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (downloadRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("downloadRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(downloadRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (uploadRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("uploadRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(uploadRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (coverArtRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("coverArtRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coverArtRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (commentRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("commentRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(commentRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (podcastRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("podcastRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(podcastRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (shareRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("shareRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(shareRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (videoConversionRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("videoConversionRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(videoConversionRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (musicFolderId != null)
                    {
                            foreach (var item_ in musicFolderId) { urlBuilder_.Append(System.Uri.EscapeDataString("musicFolderId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (maxBitRate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("maxBitRate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(maxBitRate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SubsonicResponse> PostUpdateUserAsync(Body62 body)
        {
            return PostUpdateUserAsync(body, System.Threading.CancellationToken.None);
        }

        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual SubsonicResponse PostUpdateUser(Body62 body)
        {
            return System.Threading.Tasks.Task.Run(async () => await PostUpdateUserAsync(body, System.Threading.CancellationToken.None)).GetAwaiter().GetResult();
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modifies an existing user on the server.
        /// </summary>
        /// <remarks>
        /// Modifies an existing user on the server.
        /// <br/>
        /// <br/>Requires OpenSubsonic extension name `formPost` (As returned by `getOpenSubsonicExtensions`)
        /// </remarks>
        /// <returns>Successful or failed response</returns>
        /// <exception cref="SubsonicException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubsonicResponse> PostUpdateUserAsync(Body62 body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var dictionary_ = Newtonsoft.Json.JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, string>>(json_, JsonSerializerSettings);
                    var content_ = new System.Net.Http.FormUrlEncodedContent(dictionary_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "rest/updateUser"
                    urlBuilder_.Append("rest/updateUser");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubsonicResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new SubsonicException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 405)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("HTTP form POST (`formPost`) Extension not supported", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new SubsonicException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new SubsonicException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new SubsonicException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubsonicException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SubsonicException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubsonicException<TResult> : SubsonicException
    {
        public TResult Result { get; private set; }

        public SubsonicException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765